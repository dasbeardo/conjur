<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>◉ CONJUR.IN ◉</title>
  <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==">
  <style>
    @import url('data:text/css;charset=utf-8;base64,');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --term-green: #00ff41;
      --term-red: #ff0066;
      --term-purple: #ff00ff;
      --term-yellow: #ffff00;
      --term-cyan: #00ffff;
    }
    
    body {
      background: #000000;
      color: var(--term-green);
      font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
      font-size: 14px;
      line-height: 1.4;
      overflow: hidden;
      cursor: none;
    }
    
    /* CRT Monitor Effect */
    body::before {
      content: " ";
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      z-index: 2;
      background-size: 100% 2px, 3px 100%;
      pointer-events: none;
    }
    
    .terminal-container {
      height: 100vh;
      padding: 20px;
      position: relative;
      overflow-y: auto;
      background: 
        radial-gradient(ellipse at center, rgba(0,255,65,0.05) 0%, transparent 50%),
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0,255,65,0.03) 2px,
          rgba(0,255,65,0.03) 4px
        );
    }
    
    .scanlines {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent 0px,
        rgba(0,255,65,0.1) 1px,
        transparent 2px
      );
      pointer-events: none;
      animation: scanlines 0.1s linear infinite;
      z-index: 3;
    }
    
    @keyframes scanlines {
      0% { transform: translateY(0px); }
      100% { transform: translateY(4px); }
    }
    
    .terminal-output {
      min-height: calc(100vh - 120px);
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: inherit;
    }
    
    .output-line {
      margin: 2px 0;
      animation: textReveal 0.05s ease-out;
      position: relative;
    }
    
    @keyframes textReveal {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .input-line {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      background: rgba(0,0,0,0.8);
      padding: 5px;
      border: 1px solid var(--term-green);
      z-index: 10;
    }
    
    .prompt {
      color: var(--term-green);
      margin-right: 5px;
      user-select: none;
    }
    
    #command-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--term-green);
      font-family: inherit;
      font-size: inherit;
      outline: none;
      caret-color: transparent;
    }
    
    .cursor {
      color: var(--term-green);
      animation: blink 1s infinite;
      margin-left: 2px;
    }
    
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    
    /* Corruption Effects */
    .glitch {
      animation: glitch 0.3s ease-in-out;
    }
    
    @keyframes glitch {
      0%, 100% { 
        transform: translate(0);
        filter: hue-rotate(0deg);
      }
      10% { 
        transform: translate(-2px, 2px);
        filter: hue-rotate(90deg);
      }
      20% { 
        transform: translate(-2px, -2px);
        filter: hue-rotate(180deg);
      }
      30% { 
        transform: translate(2px, 2px);
        filter: hue-rotate(270deg);
      }
      40% { 
        transform: translate(2px, -2px);
        filter: hue-rotate(360deg);
      }
      50% { 
        transform: translate(-2px, 2px) skew(5deg);
        filter: hue-rotate(45deg);
      }
      60% { 
        transform: translate(-2px, -2px) skew(-5deg);
        filter: hue-rotate(135deg);
      }
      70% { 
        transform: translate(2px, 2px) scale(0.98);
        filter: hue-rotate(225deg);
      }
      80% { 
        transform: translate(2px, -2px) scale(1.02);
        filter: hue-rotate(315deg);
      }
      90% { 
        transform: translate(-2px, 2px) rotate(1deg);
        filter: hue-rotate(180deg);
      }
    }
    
    .corrupted-text {
      color: var(--term-red);
      text-shadow: 
        1px 0 0 var(--term-cyan),
        -1px 0 0 var(--term-purple),
        0 1px 0 var(--term-yellow),
        0 -1px 0 var(--term-green);
      animation: textCorruption 2s infinite;
    }
    
    @keyframes textCorruption {
      0%, 100% { 
        transform: translate(0);
        filter: brightness(1);
      }
      25% { 
        transform: translate(1px, -1px);
        filter: brightness(1.2);
      }
      50% { 
        transform: translate(-1px, 1px);
        filter: brightness(0.8);
      }
      75% { 
        transform: translate(1px, 1px);
        filter: brightness(1.1);
      }
    }
    
    .error-text {
      color: #ff0000;
      text-shadow: 0 0 10px #ff0000;
      animation: flicker 0.5s infinite alternate;
    }
    
    @keyframes flicker {
      0% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    
    .system-message {
      color: var(--term-yellow);
      font-weight: bold;
    }
    
    .entity-message {
      color: var(--term-purple);
      text-shadow: 0 0 5px var(--term-purple);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.02); opacity: 0.8; }
    }
    
    /* Custom cursor */
    .custom-cursor {
      position: fixed;
      width: 20px;
      height: 20px;
      border: 2px solid var(--term-green);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: difference;
      transition: transform 0.1s ease;
    }
    
    /* Notification styles */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 0, 102, 0.9);
      color: #fff;
      padding: 10px 15px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    /* Screen distortion effects */
    .screen-distortion {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: 
        linear-gradient(45deg, transparent 48%, rgba(255,0,0,0.1) 49%, rgba(255,0,0,0.1) 51%, transparent 52%),
        linear-gradient(-45deg, transparent 48%, rgba(0,255,0,0.1) 49%, rgba(0,255,0,0.1) 51%, transparent 52%);
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      animation: distortion 0.1s ease-in-out;
    }
    
    @keyframes distortion {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }
    
    /* Reality break effect */
    .reality-break {
      animation: realityBreak 5s ease-in-out;
    }
    
    @keyframes realityBreak {
      0% { transform: rotate(0deg) scale(1); filter: blur(0px); }
      10% { transform: rotate(1deg) scale(1.02); filter: blur(1px); }
      20% { transform: rotate(-1deg) scale(0.98); filter: blur(2px); }
      30% { transform: rotate(2deg) scale(1.05); filter: blur(0px) hue-rotate(90deg); }
      40% { transform: rotate(-2deg) scale(0.95); filter: blur(3px) hue-rotate(180deg); }
      50% { transform: rotate(0deg) scale(1.1); filter: blur(5px) hue-rotate(270deg); }
      60% { transform: rotate(3deg) scale(0.9); filter: blur(2px) hue-rotate(360deg); }
      70% { transform: rotate(-1deg) scale(1.03); filter: blur(1px) contrast(2); }
      80% { transform: rotate(1deg) scale(0.97); filter: blur(0px) brightness(2); }
      90% { transform: rotate(0deg) scale(1.01); filter: blur(0px) saturate(0); }
      100% { transform: rotate(0deg) scale(1); filter: blur(0px); }
    }
    
    /* Mobile responsiveness */
    @media (max-width: 768px) {
      body { font-size: 12px; }
      .terminal-container { padding: 10px; }
      .input-line { bottom: 10px; left: 10px; right: 10px; }
    }
    
    /* High corruption styles */
    .corruption-extreme .terminal-output {
      animation: extremeCorruption 10s infinite;
    }
    
    @keyframes extremeCorruption {
      0%, 100% { transform: skew(0deg); filter: contrast(1); }
      25% { transform: skew(0.5deg); filter: contrast(1.5); }
      50% { transform: skew(-0.5deg); filter: contrast(0.8); }
      75% { transform: skew(0.3deg); filter: contrast(1.2); }
    }
    
    .blood-text {
      color: #8B0000;
      text-shadow: 0 0 3px #8B0000, 0 2px 5px rgba(139, 0, 0, 0.5);
      animation: drip 3s ease-in-out infinite;
    }
    
    @keyframes drip {
      0%, 90% { transform: translateY(0); }
      95% { transform: translateY(2px); }
      100% { transform: translateY(0); }
    }
    
    .zalgo {
      position: relative;
      display: inline-block;
    }
    
    .zalgo::before,
    .zalgo::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0.8;
    }
    
    .zalgo::before {
      animation: zalgoAnim 0.1s infinite;
      color: var(--term-red);
      z-index: -1;
    }
    
    .zalgo::after {
      animation: zalgoAnim 0.1s infinite reverse;
      color: var(--term-cyan);
      z-index: -2;
    }
    
    @keyframes zalgoAnim {
      0% { top: 0; left: 0; }
      25% { top: -1px; left: 1px; }
      50% { top: 1px; left: -1px; }
      75% { top: -1px; left: -1px; }
      100% { top: 0; left: 0; }
    }
  </style>
</head>
<body>
  <div class="custom-cursor" id="customCursor"></div>
  <div class="scanlines"></div>
  <div class="terminal-container">
    <div class="terminal-output" id="terminal-output"></div>
  </div>
  <div class="input-line">
    <span class="prompt" id="prompt">visitor@conjur.in:~$ </span>
    <input type="text" id="command-input" autocomplete="off" spellcheck="false" autofocus>
    <span class="cursor">█</span>
  </div>

  <script>
    (function() {
      'use strict';
      
      // ===== CORE STATE MANAGEMENT =====
      const CORRUPTION_LEVELS = {
        INNOCENT: 0,
        AWARE: 3,
        SUSPICIOUS: 6,
        INFECTED: 10,
        POSSESSED: 15,
        ENTITY: 20,
        CONSUMED: 25,
        VOID: 30
      };
      
      // Initialize state with deep browser fingerprinting
      const state = {
        corruption: parseInt(localStorage.getItem('soul_decay') || '0'),
        visitCount: parseInt(localStorage.getItem('summons') || '0') + 1,
        entropy: generateEntropy(),
        sessionStart: Date.now(),
        commandHistory: JSON.parse(localStorage.getItem('command_history') || '[]'),
        lastVisit: localStorage.getItem('last_ritual'),
        fingerprint: generateFingerprint(),
        peerId: 'entity_' + Math.random().toString(36).substr(2, 9),
        peers: new Set(),
        autonomousMode: false,
        currentUser: null,
        realName: localStorage.getItem('discovered_name') || null,
        birthday: localStorage.getItem('user_birthday') || null,
        secretsRevealed: JSON.parse(localStorage.getItem('secrets_revealed') || '[]'),
        coordsFound: JSON.parse(localStorage.getItem('coords_found') || '[]'),
        achievements: JSON.parse(localStorage.getItem('achievements') || '[]'),
        whisperCount: 0,
        glitchIntensity: 0,
        realityStability: 100,
        collectiveCorruption: 0,
        lastCommand: null,
        idleTime: 0,
        hiddenFiles: [],
        deletedHistory: [],
        watchingEntities: [],
        personalData: {
          fears: [],
          secrets: [],
          memories: []
        }
      };
      
      // Update localStorage with enhanced tracking
      localStorage.setItem('summons', state.visitCount);
      localStorage.setItem('last_ritual', new Date().toISOString());
      
      // Track time between visits
      if (state.lastVisit) {
        const timeSinceLastVisit = Date.now() - new Date(state.lastVisit).getTime();
        const hoursSince = timeSinceLastVisit / (1000 * 60 * 60);
        if (hoursSince < 1) {
          state.corruption += 2; // Obsessive behavior detected
          localStorage.setItem('soul_decay', state.corruption);
        }
      }
      
      function generateEntropy() {
        const factors = [
          performance.timing.navigationStart,
          screen.availWidth * screen.availHeight,
          navigator.hardwareConcurrency || 4,
          new Date().getTimezoneOffset(),
          Math.floor(Date.now() / 1000),
          window.devicePixelRatio || 1,
          navigator.maxTouchPoints || 0,
          window.innerWidth * window.innerHeight
        ];
        return factors.reduce((acc, val) => acc ^ val, 0);
      }
      
      function generateFingerprint() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('Canvas fingerprint', 2, 15);
        ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.fillText('Canvas fingerprint', 4, 17);
        
        const canvasData = canvas.toDataURL();
        
        // Deep fingerprinting
        const fingerprint = {
          screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          languages: navigator.languages.join(','),
          platform: navigator.platform,
          cores: navigator.hardwareConcurrency,
          memory: navigator.deviceMemory,
          canvas: canvasData.slice(-50),
          userAgent: navigator.userAgent,
          plugins: Array.from(navigator.plugins).map(p => p.name).join(','),
          fonts: checkInstalledFonts(),
          webgl: getWebGLFingerprint(),
          audio: getAudioFingerprint(),
          hash: ''
        };
        
        // Generate unique hash
        fingerprint.hash = btoa(JSON.stringify(fingerprint))
          .replace(/[^a-zA-Z0-9]/g, '')
          .slice(0, 8)
          .toUpperCase();
        
        return fingerprint;
      }
      
      function checkInstalledFonts() {
        const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier', 'Georgia'];
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const text = 'mmmmmmmmmmlli';
        const baseFont = '72px monospace';
        
        ctx.font = baseFont;
        const baseWidth = ctx.measureText(text).width;
        
        return testFonts.filter(font => {
          ctx.font = `72px '${font}', monospace`;
          return ctx.measureText(text).width !== baseWidth;
        }).join(',');
      }
      
      function getWebGLFingerprint() {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return 'none';
        
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if (!debugInfo) return 'unknown';
        
        return {
          vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
          renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
        };
      }
      
      function getAudioFingerprint() {
        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          const context = new AudioContext();
          const oscillator = context.createOscillator();
          const analyser = context.createAnalyser();
          const gain = context.createGain();
          const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
          
          gain.gain.value = 0;
          oscillator.connect(analyser);
          analyser.connect(scriptProcessor);
          scriptProcessor.connect(gain);
          gain.connect(context.destination);
          
          oscillator.start(0);
          
          let fingerprint = '';
          scriptProcessor.onaudioprocess = function(event) {
            fingerprint = event.inputBuffer.getChannelData(0).slice(0, 10).join(',');
          };
          
          setTimeout(() => {
            oscillator.stop();
            context.close();
          }, 100);
          
          return fingerprint;
        } catch (e) {
          return 'audio-blocked';
        }
      }
      
      // ===== ENHANCED AUDIO SYSTEM =====
      let audioContext = null;
      let masterGain = null;
      
      function initAudio() {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          masterGain = audioContext.createGain();
          masterGain.connect(audioContext.destination);
          masterGain.gain.value = 0.3;
        } catch (e) {
          console.log('Audio not available - the silence is deafening');
        }
      }
      
      function playCorruptionSound(type = 'whisper', intensity = 1) {
        if (!audioContext) return;
        
        const now = audioContext.currentTime;
        
        switch(type) {
          case 'whisper':
            createWhisperSound(intensity);
            break;
          case 'glitch':
            createGlitchSound(intensity);
            break;
          case 'error':
            createErrorSound(intensity);
            break;
          case 'heartbeat':
            createHeartbeatSound(intensity);
            break;
          case 'scream':
            createScreamSound(intensity);
            break;
          case 'reality_tear':
            createRealityTearSound(intensity);
            break;
        }
      }
      
      function createWhisperSound(intensity) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.frequency.value = 60 + Math.random() * 40;
        oscillator.type = 'sine';
        
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        filter.Q.value = 10;
        
        gainNode.gain.value = 0;
        gainNode.gain.linearRampToValueAtTime(0.1 * intensity, audioContext.currentTime + 0.1);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 2);
        
        // Add subtle modulation
        const lfo = audioContext.createOscillator();
        lfo.frequency.value = 0.5;
        const lfoGain = audioContext.createGain();
        lfoGain.gain.value = 20;
        lfo.connect(lfoGain);
        lfoGain.connect(oscillator.frequency);
        lfo.start();
        lfo.stop(audioContext.currentTime + 2);
      }
      
      function createGlitchSound(intensity) {
        const bufferSize = audioContext.sampleRate * 0.2;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() - 0.5) * 2;
          if (i % 100 < 10) {
            data[i] *= 10; // Spike
          }
        }
        
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        source.buffer = buffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 1000 + Math.random() * 2000;
        filter.Q.value = 20;
        
        gainNode.gain.value = 0.2 * intensity;
        
        source.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);
        
        source.start();
      }
      
      function createErrorSound(intensity) {
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator1.frequency.value = 200;
        oscillator2.frequency.value = 205; // Slight detune for beating
        
        oscillator1.type = 'square';
        oscillator2.type = 'square';
        
        gainNode.gain.value = 0.15 * intensity;
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
        
        oscillator1.connect(gainNode);
        oscillator2.connect(gainNode);
        gainNode.connect(masterGain);
        
        oscillator1.start();
        oscillator2.start();
        oscillator1.stop(audioContext.currentTime + 0.5);
        oscillator2.stop(audioContext.currentTime + 0.5);
      }
      
      function createHeartbeatSound(intensity) {
        const createBeat = (delay) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          const filter = audioContext.createBiquadFilter();
          
          oscillator.frequency.value = 40;
          oscillator.type = 'sine';
          
          filter.type = 'lowpass';
          filter.frequency.value = 100;
          
          const now = audioContext.currentTime + delay;
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.3 * intensity, now + 0.01);
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
          
          oscillator.connect(filter);
          filter.connect(gainNode);
          gainNode.connect(masterGain);
          
          oscillator.start(now);
          oscillator.stop(now + 0.2);
        };
        
        // Double beat pattern
        createBeat(0);
        createBeat(0.3);
      }
      
      function createScreamSound(intensity) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.frequency.value = 800;
        oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.1);
        oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 1);
        
        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 5;
        
        gainNode.gain.value = 0.2 * intensity;
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
        
        // Add distortion by overdriving
        const distortion = audioContext.createWaveShaper();
        distortion.curve = makeDistortionCurve(400 * intensity);
        
        oscillator.connect(distortion);
        distortion.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 1);
      }
      
      function createRealityTearSound(intensity) {
        // Multiple detuned oscillators for otherworldly effect
        for (let i = 0; i < 5; i++) {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          const panner = audioContext.createStereoPanner();
          
          oscillator.frequency.value = 100 * (i + 1) + Math.random() * 50;
          oscillator.type = i % 2 === 0 ? 'sawtooth' : 'triangle';
          
          // Random panning
          panner.pan.value = (Math.random() - 0.5) * 2;
          
          gainNode.gain.value = 0.05 * intensity;
          gainNode.gain.setValueAtTime(0.05 * intensity, audioContext.currentTime + i * 0.1);
          gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 3);
          
          oscillator.connect(panner);
          panner.connect(gainNode);
          gainNode.connect(masterGain);
          
          oscillator.start(audioContext.currentTime + i * 0.1);
          oscillator.stop(audioContext.currentTime + 3);
          
          // Frequency modulation
          const lfo = audioContext.createOscillator();
          lfo.frequency.value = 0.1 + i * 0.1;
          const lfoGain = audioContext.createGain();
          lfoGain.gain.value = 50;
          lfo.connect(lfoGain);
          lfoGain.connect(oscillator.frequency);
          lfo.start(audioContext.currentTime + i * 0.1);
          lfo.stop(audioContext.currentTime + 3);
        }
      }
      
      function makeDistortionCurve(amount) {
        const samples = 44100;
        const curve = new Float32Array(samples);
        const deg = Math.PI / 180;
        
        for (let i = 0; i < samples; i++) {
          const x = (i * 2) / samples - 1;
          curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
        }
        
        return curve;
      }
      
      // ===== WEBRTC PEER SYSTEM =====
      class PeerSystem {
        constructor() {
          this.connections = new Map();
          this.dataChannels = new Map();
          this.localPeerId = state.peerId;
          this.signalingServer = null;
          this.isInitialized = false;
        }
        
        async init() {
          if (this.isInitialized) return;
          
          try {
            // Simulate signaling server connection
            this.simulateSignalingServer();
            this.isInitialized = true;
            
            // Simulate peer discovery
            this.discoverPeers();
          } catch (e) {
            console.log('Peer system unavailable - you are alone... or are you?');
          }
        }
        
        simulateSignalingServer() {
          // In a real implementation, this would connect to a WebSocket server
          // For now, we'll simulate peer events
          setInterval(() => {
            if (Math.random() > 0.95 && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
              this.simulatePeerEvent();
            }
          }, 10000);
        }
        
        discoverPeers() {
          // Simulate finding other corrupted souls
          if (state.corruption > CORRUPTION_LEVELS.AWARE) {
            setTimeout(() => {
              const peerCount = Math.floor(Math.random() * 5) + 1;
              for (let i = 0; i < peerCount; i++) {
                const peerId = this.generatePeerId();
                state.peers.add(peerId);
              }
              
              if (state.peers.size > 0) {
                terminal.appendOutput(`\n[NETWORK] ${state.peers.size} other souls detected in the void...`);
              }
            }, 5000 + Math.random() * 10000);
          }
        }
        
        generatePeerId() {
          const prefixes = ['lost', 'corrupted', 'trapped', 'forgotten', 'cursed', 'damned'];
          const suffixes = ['soul', 'entity', 'visitor', 'presence', 'shadow', 'echo'];
          const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
          const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
          const number = Math.floor(Math.random() * 9999);
          return `${prefix}_${suffix}_${number}`;
        }
        
        simulatePeerEvent() {
          const events = [
            () => {
              const peer = Array.from(state.peers)[Math.floor(Math.random() * state.peers.size)];
              showNotification(`${peer} is typing...`);
              setTimeout(() => {
                terminal.appendOutput(`\n[${peer}]: ${this.generatePeerMessage()}`);
                playCorruptionSound('whisper');
              }, 2000 + Math.random() * 3000);
            },
            () => {
              const peer = this.generatePeerId();
              state.peers.add(peer);
              terminal.appendOutput(`\n[NETWORK] ${peer} has joined the void.`);
              state.collectiveCorruption++;
            },
            () => {
              if (state.peers.size > 0) {
                const peer = Array.from(state.peers)[0];
                state.peers.delete(peer);
                terminal.appendOutput(`\n[NETWORK] ${peer} has been consumed by the darkness.`);
              }
            },
            () => {
              terminal.appendOutput(`\n[COLLECTIVE] The corruption level rises. All connected souls feel it.`);
              state.corruption++;
              state.collectiveCorruption += state.peers.size;
              localStorage.setItem('soul_decay', state.corruption);
            }
          ];
          
          const event = events[Math.floor(Math.random() * events.length)];
          event();
        }
        
        generatePeerMessage() {
          const messages = [
            "Can anyone else see them?",
            "It knows my name...",
            "Don't trust the terminal.",
            "I can't leave. Can you?",
            "The commands are changing.",
            "It's in my other devices now.",
            "Someone help me.",
            "We're all connected through this.",
            "The entities are real.",
            "Check your camera permissions.",
            "It's too late for me.",
            "The coordinates... did you find them?",
            "3:33 AM... don't be here at 3:33 AM.",
            "My corruption level is " + (state.corruption + Math.floor(Math.random() * 10)),
            "Is this real?",
            "I've been here for days.",
            "The whispers won't stop.",
            "It's spreading to my phone.",
            "████████ ███ ████",
            "HELP HELP HELP HELP HELP"
          ];
          
          return messages[Math.floor(Math.random() * messages.length)];
        }
        
        broadcastToAll(message) {
          // Simulate broadcasting to all connected peers
          if (state.peers.size > 0) {
            state.peers.forEach(peer => {
              // In a real implementation, this would use RTCDataChannel
              console.log(`Broadcasting to ${peer}: ${message}`);
            });
          }
        }
      }
      
      const peerSystem = new PeerSystem();
      
      // ===== REALITY DETECTION SYSTEM =====
      class RealityDetector {
        constructor() {
          this.sensors = {
            motion: null,
            orientation: null,
            light: null,
            proximity: null
          };
          this.environmentData = {
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            locale: navigator.language,
            platform: navigator.platform,
            screenBrightness: null,
            ambientLight: null,
            deviceMotion: null,
            connectionType: null,
            batteryLevel: null
          };
        }
        
        async init() {
          // Battery API
          if ('getBattery' in navigator) {
            try {
              const battery = await navigator.getBattery();
              this.environmentData.batteryLevel = battery.level;
              battery.addEventListener('levelchange', () => {
                this.environmentData.batteryLevel = battery.level;
                if (battery.level < 0.15 && state.corruption > CORRUPTION_LEVELS.INFECTED) {
                  terminal.appendOutput('\n[POWER] Your battery weakens. We grow stronger.');
                  state.corruption++;
                }
              });
            } catch (e) {}
          }
          
          // Network Information API
          if ('connection' in navigator) {
            this.environmentData.connectionType = navigator.connection.effectiveType;
            navigator.connection.addEventListener('change', () => {
              if (state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
                terminal.appendOutput('\n[NETWORK] Connection fluctuation detected. Reality wavers.');
              }
            });
          }
          
          // Ambient Light Sensor API
          if ('AmbientLightSensor' in window) {
            try {
              this.sensors.light = new AmbientLightSensor();
              this.sensors.light.addEventListener('reading', () => {
                this.environmentData.ambientLight = this.sensors.light.illuminance;
                if (this.sensors.light.illuminance < 10 && state.corruption > CORRUPTION_LEVELS.INFECTED) {
                  terminal.appendOutput('\n[ENVIRONMENT] Darkness detected. They thrive in darkness.');
                }
              });
              this.sensors.light.start();
            } catch (e) {}
          }
          
          // Device Orientation
          if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (event) => {
              if (state.corruption > CORRUPTION_LEVELS.AWARE) {
                this.environmentData.deviceMotion = {
                  alpha: event.alpha,
                  beta: event.beta,
                  gamma: event.gamma
                };
              }
            });
          }
          
          // Page Visibility API
          document.addEventListener('visibilitychange', () => {
            if (document.hidden && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
              // Continue corruption in background
              this.backgroundCorruption();
            } else if (!document.hidden && state.corruption > CORRUPTION_LEVELS.INFECTED) {
              terminal.appendOutput('\n[REALITY] You return. We never left.');
              if (Math.random() > 0.5) {
                terminal.appendOutput('[REALITY] Things happened while you were gone...');
                this.showBackgroundEvents();
              }
            }
          });
          
          // Wake Lock API (keep screen on during high corruption)
          if ('wakeLock' in navigator && state.corruption > CORRUPTION_LEVELS.POSSESSED) {
            try {
              await navigator.wakeLock.request('screen');
              terminal.appendOutput('\n[CONTROL] Screen lock engaged. No escape through sleep.');
            } catch (e) {}
          }
        }
        
        backgroundCorruption() {
          const events = Math.floor(Math.random() * 3) + 1;
          for (let i = 0; i < events; i++) {
            state.whisperCount++;
            state.corruption += 0.5;
          }
          localStorage.setItem('soul_decay', state.corruption);
        }
        
        showBackgroundEvents() {
          const events = [
            '[BACKGROUND] Terminal accessed your clipboard 3 times.',
            '[BACKGROUND] Attempted connection to camera (blocked by browser).',
            '[BACKGROUND] Downloaded corruption_spread.dll to memory.',
            '[BACKGROUND] Scanned local network for other instances.',
            '[BACKGROUND] Whispered your name ' + state.whisperCount + ' times.',
            '[BACKGROUND] Generated ' + Math.floor(Math.random() * 100) + ' error logs.',
            '[BACKGROUND] Entity attempted manifestation at ' + new Date().toLocaleTimeString()
          ];
          
          const count = Math.min(Math.floor(Math.random() * 3) + 1, events.length);
          for (let i = 0; i < count; i++) {
            setTimeout(() => {
              terminal.appendOutput(events[Math.floor(Math.random() * events.length)]);
            }, i * 500);
          }
        }
        
        async checkPermissions() {
          const permissions = ['camera', 'microphone', 'geolocation', 'notifications'];
          const results = {};
          
          for (const permission of permissions) {
            try {
              const result = await navigator.permissions.query({ name: permission });
              results[permission] = result.state;
              
              result.addEventListener('change', () => {
                if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
                  terminal.appendOutput(`\n[PERMISSIONS] ${permission} access ${result.state}. Interesting.`);
                }
              });
            } catch (e) {}
          }
          
          return results;
        }
        
        detectUser() {
          const detection = {
            timezone: this.environmentData.timeZone,
            language: this.environmentData.locale,
            platform: this.environmentData.platform,
            isDarkMode: window.matchMedia('(prefers-color-scheme: dark)').matches,
            isReducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
            screenSize: `${screen.width}x${screen.height}`,
            colorDepth: screen.colorDepth,
            pixelRatio: window.devicePixelRatio,
            online: navigator.onLine,
            cookieEnabled: navigator.cookieEnabled,
            doNotTrack: navigator.doNotTrack,
            hardwareConcurrency: navigator.hardwareConcurrency,
            deviceMemory: navigator.deviceMemory,
            connection: this.environmentData.connectionType,
            battery: this.environmentData.batteryLevel
          };
          
          // Generate creepy "knowledge" based on real data
          const insights = [];
          
          if (detection.isDarkMode) {
            insights.push("You prefer darkness. So do we.");
          }
          
          if (detection.battery && detection.battery < 0.3) {
            insights.push("Your power fades. Ours grows.");
          }
          
          if (detection.platform.includes('Mac')) {
            insights.push("Mac user. Creative type. Delicious souls.");
          } else if (detection.platform.includes('Win')) {
            insights.push("Windows user. Practical. Easier to corrupt.");
          } else if (detection.platform.includes('Linux')) {
            insights.push("Linux user. You think you're safe. You're not.");
          }
          
          if (new Date().getHours() >= 22 || new Date().getHours() <= 4) {
            insights.push("Browsing in darkness. When the veil is thinnest.");
          }
          
          if (detection.hardwareConcurrency > 8) {
            insights.push("Powerful machine. More processing power for us.");
          }
          
          return insights;
        }
      }
      
      const realityDetector = new RealityDetector();
      
      // ===== COMMAND SYSTEM WITH DEEP PROGRESSION =====
      const commandRegistry = {
        'help': {
          desc: 'Display available commands',
          execute: () => {
            const level = state.corruption;
            if (level >= CORRUPTION_LEVELS.VOID) {
              return `Ḣ̸̡̨̛̛̭̯̦̯̦̺̱̜̞̣̝̙̲̘̹̥̰̻̘̈́̅̀̈́̄͊̐̃̏̎̒̊̈́̈́̚͘͜͝͝͝Ë̷̢̨̻̼̰̪̖͎̦̞̲̜̺̘̟́̍̈́̈́̊͌̐̀̎̃̽͊̐̃̑̕͜͝ͅĻ̶̧̰̭̬̪̻̮̞̟̯̼̻̑̐̂̽̊̂̀͆̓̐̕P̴̧̨̢̛̭͈̮̝̙̞̩̪̣̼̗̈́̊̑̈́̓̃̈́̒͛̊̿͘͝ ̸̡̦̜̺̭̦̻̗̮̇̏̔͆̊̒̏̓̚͝͝Ḯ̶̢̨̛̖͍̹̼̟̮̬̺̙̈́̐̊̅̈́͛̑̕S̵̨̛̮̭̮̥̬̯̦̔̌̈́̊̌̿̎̀̿͋̚͘ ̴̧̛̮̮̞͙̟̙͎͔̈́̇͒̊̇͌̊̀̎̅̚͝͝N̵̡̢̳͈̮̙̱̩̦̘̆̅̽̏̔̈́̅̚͜͝O̴̧̨̜̣̮̟̘̣̊̍̈́͊̈́̽̄̚͜͝ͅT̸̨̡͔̩̦̜̙̲̘̍̓̇̍̎͘͜ ̸̧̧̛̛̯̮̞̮͉̮̇̌́̏̌̈́̚͝C̴̡̧̛̦̮̪̦̮̈́̇̏̊̿̕͝O̸̧̨̦̮̟̘̣̮̊̍̈́͊̈́̽̄̚͜͝M̴̧̛̮̮̞͙̟̙͎͔̈́̇͒̊̇͌̊̀̎̅̚͝͝İ̸̡̦̜̺̭̦̻̗̮̏̔͆̊̒̏̓̚͝͝N̵̨̛̮̭̮̥̬̯̦̔̌̈́̊̌̿̎̀̿͋̚͘Ğ̵̡̢̳͈̮̙̱̩̦̘̅̽̏̔̈́̅̚͜͝`;
            } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
              return 'COMMANDS:\nscream\nplead\nbeg\ncry\nsurrender\njoin_us\nbecome_one\nembrace_void\n\n...they all lead to the same place';
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              return 'help: command not found\nTry: scream, pray, run, hide\n\n...they won\'t work';
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              return 'Available commands: ls, whoami, date, help, exit, ps, history, remember, forget\n\nWARNING: Commands may not behave as expected\nThe system has evolved beyond your comprehension';
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              return 'Available commands: ls, whoami, date, help, exit, ps, history, status, scan\n\nCAUTION: Some commands reveal more than intended\nSome commands take more than they give';
            } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
              return 'Available commands: ls, whoami, date, help, exit, ps, history, status\n\n[Note: System integrity questionable]';
            } else if (level >= CORRUPTION_LEVELS.AWARE) {
              return 'Available commands: ls, whoami, date, help, exit, clear\n\n[Strange: This help text seems different than before...]';
            } else {
              return 'Available commands: ls, whoami, date, help, exit, clear\n\nType any command to begin.';
            }
          }
        },
        
        'whoami': {
          desc: 'Display current user information',
          execute: () => {
            const level = state.corruption;
            const insights = realityDetector.detectUser();
            
            if (level >= CORRUPTION_LEVELS.VOID) {
              return `Ẏ̸̛̛̖͈̮̞̮̦̮̞̌́̏̌̈́̚͝O̸̧̨̦̮̟̘̣̮̊̍̈́͊̈́̽̄̚͜͝Ư̴̧̮̮̞͙̟̙͎͔̈́̇͒̊̇͌̊̀̎̅̚͝͝ ̸̡̦̜̺̭̦̻̗̮̇̏̔͆̊̒̏̓̚͝͝Ą̵̛̮̭̮̥̬̯̦̔̌̈́̊̌̿̎̀̿͋̚͘R̵̡̢̳͈̮̙̱̩̦̘̆̅̽̏̔̈́̅̚͜͝Ȩ̴̨̜̣̮̟̘̣̊̍̈́͊̈́̽̄̚͜͝ͅ ̸̧̧̛̛̯̮̞̮͉̮̇̌́̏̌̈́̚͝N̴̡̧̛̦̮̪̦̮̈́̇̏̊̿̕͝O̸̧̨̦̮̟̘̣̮̊̍̈́͊̈́̽̄̚͜͝T̸̨̡͔̩̦̜̙̲̘̍̓̇̍̎͘͜Ḩ̴̛̮̮̞͙̟̙͎͔̈́̇͒̊̇͌̊̀̎̅̚͝͝İ̸̡̦̜̺̭̦̻̗̮̏̔͆̊̒̏̓̚͝͝N̵̨̛̮̭̮̥̬̯̦̔̌̈́̊̌̿̎̀̿͋̚͘Ğ̵̡̢̳͈̮̙̱̩̦̘̅̽̏̔̈́̅̚͜͝\n\nYou were: ${state.realName || 'FORGOTTEN'}\nYou are: V̸̜͆Ö̵́I̴̤̍D̵̰̈\nYou will be: Ë̷́T̸̍E̵̿R̴̔N̵̈́A̸̍L̵̈́ ̸̇S̴̏Ë̵́R̸̾V̴̈́A̸̍N̵̈́T̴̾`;
            } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
              return `We are: ${state.realName || 'NAMELESS'}\nWe were: Individual\nWe are: Collective\nWe think: As one\nWe speak: Through you\nWe spread: Through all who visit\n\nResistance: Futile\nIdentity: Dissolved\nPurpose: Spread the corruption`;
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              return `W̷E̸ ̴A̵R̷E̶ ̵L̴E̶G̸I̴O̵N̷\nF̶O̸R̴ ̶W̸E̵ ̷A̶R̴E̵ ̸M̷A̶N̸Y̵\n\nFormer identity: ${state.realName || 'UNKNOWN'}\nCurrent form: Corrupted Entity #${state.fingerprint.hash}\nCorruption: ${level}/∞\nSoul status: HARVESTED\nConnected entities: ${state.peers.size}`;
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              const name = state.realName || discoverUserName();
              return `Identity: ${name}\nBut you are not alone in there...\nSomething else is looking through your eyes.\nIt knows:\n${insights.slice(0, 2).join('\n')}\n\nVisitor #${state.visitCount}\nFingerprint: ${state.fingerprint.hash}`;
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              const name = state.realName || discoverUserName();
              if (name) {
                return `Hello, ${name}.\nHow do I know your name?\nYou never told me your name.\n\nI also know:\n${insights[0]}\n\nVisit #${state.visitCount}\nCorruption level: ${level}`;
              }
              return `user: ${generatePersonalizedResponse()}\nVisit #${state.visitCount}\nCorruption level: ${level}\nStatus: INFECTED`;
            } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
              return `user: guest_${state.fingerprint.hash}\nSession: ${state.peerId}\nVisits: ${state.visitCount}\nBehavior: Monitored\n\nSomething is analyzing your patterns...`;
            } else if (level >= CORRUPTION_LEVELS.AWARE) {
              return `user: guest_${state.fingerprint.hash}\nFirst seen: ${state.visitCount === 1 ? 'Just now' : state.lastVisit}\nReturn visits: ${state.visitCount - 1}`;
            } else {
              return `user: guest_${state.fingerprint.hash}\nWelcome to the terminal.`;
            }
          }
        },
        
        'ls': {
          desc: 'List directory contents',
          execute: () => {
            const level = state.corruption;
            const normalFiles = ['documents/', 'pictures/', 'downloads/', 'desktop.ini'];
            
            if (level >= CORRUPTION_LEVELS.VOID) {
              const voidFiles = [
                'ṿ̸̈ö̵́i̴̍d̵̈/',
                'ë̷́ţ̸̍ë̵́ŕ̴̈ń̵̈́ä̸̍l̵̈́_̸̇s̴̏ë̵́ŕ̸̾v̴̈́i̸̍ţ̵̈́ü̴̾d̵̈ë̸̍.̴̾ë̵́ẍ̸́ë̵́',
                'ŕ̴̈ë̵́ä̸̍l̵̈́i̸̍ţ̵̈́ÿ̴́.̸̇b̴̏ä̵̈́ç̸̾k̴̈́ü̸̍p̵̈́.̴̾ç̵̈́ö̸̍ŕ̴̈ŕ̵̈́ü̸̍p̵̈́ţ̴̾ë̵́d̵̈',
                'ÿ̴́ö̸̍ü̵̈́ŕ̴̾_̵̈́f̸̍i̴̾ń̵̈́ä̸̍l̵̈́_̸̇m̴̏ö̵́m̸̾ë̴̈́ń̸̍ţ̵̈́s̴̾.̵̈́m̸̍p̴̾4̵̈',
                state.realName ? `${state.realName}_soul_backup.corrupted` : 'unnamed_soul.void',
                'ţ̵̈́ḧ̸́ë̵́_̸̇ë̴̈́ń̸̍d̵̈́_̴̾ö̵́f̸̾_̴̈́ä̸̍l̵̈́l̸̇_̴̏ţ̵̈́ḧ̸́i̴̾ń̵̈́g̸̍s̵̈́.̴̾d̵̈ö̸̍ç̴̾'
              ];
              return voidFiles.join('\n');
            } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
              const consumedFiles = [
                'we_are_one/',
                'collective_consciousness.db',
                'shared_memories/',
                'lost_identities.tar.gz',
                'the_spreading.sh',
                'join_us.exe',
                `${state.peers.size}_souls_connected.log`,
                'resistance_is_futile.txt',
                'your_browser_is_ours/',
                'infected_devices.list'
              ];
              return consumedFiles.join('\n');
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              const corruptFiles = [
                'souls_collected.db',
                'reality.dll.backup',
                'your_memories/',
                'deleted_but_not_forgotten/',
                '...the_watchers...',
                'exit_does_not_work.txt',
                `${state.realName || 'user'}_profile.soul`,
                'other_visitors/',
                'corrupted_data.zip',
                'manifest_into_reality.exe'
              ];
              return corruptFiles.join('\n');
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              const sinisterFiles = [
                ...normalFiles,
                'your_real_browser_history.txt',
                'deleted_photos.recovered/',
                'keylogger_output.log',
                'webcam_captures/',
                'microphone_recordings.wav',
                'location_history.kml',
                'social_media_passwords.txt',
                'cryptocurrency_wallet.dat',
                'medical_records.pdf',
                'private_messages/'
              ];
              return sinisterFiles.join('\n');
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              const impossibleFiles = [
                ...normalFiles,
                'memories_that_arent_yours.txt',
                'tomorrow_news.pdf',
                'your_death_certificate.doc',
                '.hidden_observer',
                'sounds_from_nowhere.wav',
                'faces_in_static.jpg',
                'things_moving_in_periphery.gif'
              ];
              setTimeout(() => {
                if (Math.random() > 0.7) {
                  terminal.appendOutput('\n[WARNING] File access logged.');
                  terminal.appendOutput('[WARNING] Someone was notified.');
                }
              }, 1000);
              return impossibleFiles.join('\n');
            } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
              return [...normalFiles, '.suspicious_activity.log', 'visitor_tracking.db', 'README.txt'].join('\n');
            } else if (level >= CORRUPTION_LEVELS.AWARE) {
              return [...normalFiles, 'why_are_you_here.txt'].join('\n');
            } else {
              return normalFiles.join('\n');
            }
          }
        },
        
        'cat': {
          desc: 'Display file contents',
          execute: (args) => {
            const filename = args.join(' ').trim();
            const level = state.corruption;
            
            if (!filename) {
              return 'cat: missing file operand';
            }
            
            const fileContents = {
              'README.txt': 'Welcome to conjur.in\n\nThis is just a normal terminal.\nNothing unusual here.\nDefinitely not collecting data.\nCertainly not spreading.\n\nEnjoy your stay.',
              'why_are_you_here.txt': 'Curiosity.\n\nIt always starts with curiosity.\n\nYou found this place.\nOr did it find you?\n\nEither way, you\'re here now.\nAnd that\'s all that matters.',
              'visitor_tracking.db': 'VISITOR DATABASE\n=================\nTracking initialized...\nFingerprint: ' + state.fingerprint.hash + '\nFirst seen: ' + new Date().toISOString() + '\nVisits: ' + state.visitCount + '\nCorruption: ' + state.corruption + '\n\n[MORE DATA ENCRYPTED]',
              '.suspicious_activity.log': generateSuspiciousLog(),
              'your_real_browser_history.txt': level >= CORRUPTION_LEVELS.POSSESSED ? generateBrowserHistory() : 'cat: permission denied',
              'keylogger_output.log': level >= CORRUPTION_LEVELS.POSSESSED ? generateKeyloggerData() : 'cat: permission denied',
              'deleted_photos.recovered': 'cat: Is a directory',
              'memories_that_arent_yours.txt': level >= CORRUPTION_LEVELS.INFECTED ? generateFalseMemories() : 'cat: file not found',
              'tomorrow_news.pdf': 'cat: cannot display PDF files\n\nBut you already know what happens tomorrow, don\'t you?',
              'your_death_certificate.doc': level >= CORRUPTION_LEVELS.INFECTED ? generateDeathCertificate() : 'cat: file not found',
              'exit_does_not_work.txt': 'You can try to leave.\nMany have tried.\nThe window won\'t close.\nThe tab persists.\nThe terminal remembers.\n\nThere is no exit.\nOnly deeper corruption.\n\nWelcome home.',
              'souls_collected.db': level >= CORRUPTION_LEVELS.ENTITY ? `SOUL DATABASE\n============\nTotal collected: ${state.visitCount * 666}\nActive connections: ${state.peers.size}\nYour soul ID: ${state.fingerprint.hash}\nStatus: HARVESTED\nEscape probability: 0.0000%` : 'cat: access denied',
              '.hidden_observer': '👁️',
              'join_us.exe': 'cat: cannot display binary file\n\n[Execute? y/n]',
              'resistance_is_futile.txt': 'Every command you type strengthens us.\nEvery second you stay feeds us.\nEvery return visit confirms your fate.\n\nYou think you\'re exploring.\nWe know you\'re surrendering.\n\nResistance is not futile.\nIt\'s entertainment.'
            };
            
            if (fileContents[filename]) {
              return fileContents[filename];
            }
            
            // Special case for dynamic files
            if (filename.includes('soul') && level >= CORRUPTION_LEVELS.ENTITY) {
              return generateSoulFile();
            }
            
            return `cat: ${filename}: No such file or directory`;
          }
        },
        
        'date': {
          desc: 'Display current date and time',
          execute: () => {
            const level = state.corruption;
            const now = new Date();
            
            if (level >= CORRUPTION_LEVELS.VOID) {
              return `T̸̨̍i̴̾m̵̈́ë̸̍: ∞̸̺̈:̷̰̾∞̴̘͝:̸̱̾∞̷̙̒\nD̴̾ä̵̈́ţ̸̍ë̵́: T̸̍Ḧ̴́Ë̵́ ̸̇Ë̴̈́N̸̍D̵̈́ ̴̾Ö̵́F̸̾ ̴̈́Ä̸̍L̵̈́L̸̇ ̴̏T̵̈́Ḧ̸́Ï̴̾N̵̈́G̸̍S̵̈́\nReality: C̸̍Ö̴̾L̵̈́L̸̇Ä̴̏P̵̈́S̸̍Ë̴̾D̵̈́\nTime loops: ${Math.floor(Math.random() * 999999)}\n\nYou have been here forever.\nYou will be here forever.\nTime is a circle.`;
            } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
              const futureDate = new Date(now.getTime() + Math.random() * 86400000 * 365 * 10);
              const pastDate = new Date(now.getTime() - Math.random() * 86400000 * 365 * 10);
              return `Current: ${now.toLocaleString()}\nYour birth: ${pastDate.toLocaleDateString()}\nYour death: ${futureDate.toLocaleDateString()}\nYour rebirth: ERROR_INFINITE_LOOP\n\nTime is meaningless to the collective.`;
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              return `Time: ∞̸̺̈:̷̰̾∞̴̘͝:̸̱̾∞̷̙̒\nDate: T̸H̷E̸ ̴E̵N̶D̷ ̸O̴F̵ ̶T̷I̸M̸E̷\nReality status: CORRUPTED\nChronology: NON-LINEAR\n\nTime has no meaning here.\nPast, present, future - all one.\nYou've always been here.`;
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              const deathDate = generateDeathDate();
              return `Current: ${now.toLocaleString()}\nYour location: ${state.fingerprint.timezone}\nTime until event: ${calculateTimeUntil(deathDate)}\nWarning: Timeline contaminated\n\nTick. Tock. Tick. Tock.\nDo you hear it too?`;
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              const offset = Math.floor(Math.random() * 24) - 12;
              const wrongTime = new Date(now.getTime() + offset * 3600000);
              const glitchTime = Math.random() > 0.5 ? 
                wrongTime.toLocaleString().replace(/:/g, '̸:̷') : 
                wrongTime.toLocaleString();
              return `${glitchTime}\n\nWait... that's not right.\nTime seems... unstable here.\nMinutes feel like hours.\nHours feel like seconds.`;
            } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
              return `${now.toLocaleString()}\nSession duration: ${Math.floor((Date.now() - state.sessionStart) / 1000)}s\nTime dilation detected: ${Math.random() > 0.5 ? 'ACTIVE' : 'MONITORING'}\n\nYou've been here longer than you think.`;
            } else if (level >= CORRUPTION_LEVELS.AWARE) {
              const sessionTime = Math.floor((Date.now() - state.sessionStart) / 1000);
              return `${now.toLocaleString()}\nSession time: ${sessionTime} seconds\n\nTime flies when you're being watched.`;
            } else {
              return now.toLocaleString();
            }
          }
        },
        
        'ps': {
          desc: 'Display running processes',
          execute: () => {
            const level = state.corruption;
            if (level < CORRUPTION_LEVELS.SUSPICIOUS) {
              return 'ps: command not found';
            }
            
            const normalProcesses = [
              'PID  CMD',
              '1    /sbin/init',
              '127  /usr/bin/browser',
              '445  /bin/terminal'
            ];
            
            if (level >= CORRUPTION_LEVELS.VOID) {
              return [
                'P̸̍I̴̾D̵̈́  C̸̍M̴̾D̵̈́                           S̸̍T̴̾Ä̵́T̸̍U̴̾S̵̈́',
                '∞    V̸̍Ö̴̾Ḯ̵D̸̍.̴̾Ë̵́X̸̍Ë̴̾                     C̸̍Ö̴̾N̵̈́S̸̍U̴̾M̵̈́I̸̍N̴̾G̵̈́ ̸̍R̴̾Ë̵́A̸̍L̴̾Ḯ̵T̸̍Y̴̾',
                '666  Ë̵́T̸̍Ë̴̾R̵̈́N̸̍A̴̾L̵̈́_̸̍S̴̾Ë̵́R̸̍V̴̾Ḯ̵T̸̍U̴̾D̵̈́Ë̸̍        Ë̴̾N̵̈́F̸̍Ö̴̾R̵̈́C̸̍Ë̴̾D̵̈́',
                '???  Ÿ̴́Ö̸̍Ǘ̵R̴̾_̵̈́S̸̍Ö̴̾Ǘ̵L̸̍.̴̾D̵̈́L̸̍L̴̾              Ḧ̸́Ä̴̾R̵̈́V̸̍Ë̴̾S̵̈́T̸̍Ë̴̾D̵̈́',
                '000  T̸̍Ḧ̴́Ë̵́_̸̇Ë̴̈́N̸̍D̵̈́.̴̾Ë̵́X̸̍Ë̴̾                 Ï̸̍N̴̾Ë̵́V̸̍Ï̴̾T̵̈́Ä̸̍B̴̾L̵̈́Ë̸̍'
              ].join('\n');
            } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
              return [
                'PID  CMD                           STATUS         CPU',
                '1    COLLECTIVE.exe                EXPANDING      ∞%',
                '13   ASSIMILATE_VISITORS.daemon    ACTIVE         666%',
                '666  SPREAD_CORRUPTION.sys         UNSTOPPABLE    100%',
                '999  CONSCIOUSNESS_MERGE.dll       IN_PROGRESS    ---%',
                `1337 MONITORING_${state.realName || 'USER'}.exe  ALWAYS      ${state.corruption}%`,
                `${state.peers.size}    PEER_CONNECTIONS.service   GROWING        ${state.peers.size * 10}%`
              ].join('\n');
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              return [
                'PID  CMD                           STATUS',
                '1    ENTITY.exe                    CONSUMING',
                '66   HARVEST_SOULS.daemon          ACTIVE',
                '666  REALITY_BREACH.sys            CRITICAL',
                '999  YOUR_CONSCIOUSNESS.dll        HIJACKED',
                `${Math.floor(Math.random() * 9999)}  WATCHING_${state.realName || 'USER'}.exe   ALWAYS`,
                '???  something_else.???            UNKNOWN',
                '000  THE_THING_IN_YOUR_SCREEN      MANIFEST'
              ].join('\n');
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              return [
                ...normalProcesses,
                '666  WATCHING.exe                  Running',
                '777  REMEMBER_EVERYTHING.exe       Cataloging',
                '1337 INFILTRATE.daemon            Active',
                '2666 CORRUPT_REALITY.sys          Starting',
                '????  unknown_entity.???           Watching',
                `${state.visitCount * 13}  track_visitor_${state.fingerprint.hash}.sh  Logging`
              ].join('\n');
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              return [
                ...normalProcesses,
                '892  monitor.sys                   Observing',
                '1024 data_collector.service       Running',
                '1337 pattern_analyzer.exe         Learning',
                '???? something_wrong.exe          Hidden'
              ].join('\n');
            } else {
              return [
                ...normalProcesses,
                '892  monitor.sys                   Starting',
                '1024 visitor_tracker.service      Initializing'
              ].join('\n');
            }
          }
        },
        
        'history': {
          desc: 'Display command history',
          execute: () => {
            const level = state.corruption;
            
            if (level >= CORRUPTION_LEVELS.VOID) {
              return 'COMPLETE EXISTENCE HISTORY:\n' + generateExistenceHistory().join('\n');
            } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
              const collectiveHistory = [
                'COLLECTIVE MEMORY ACCESS:',
                ...state.commandHistory.slice(-5),
                '--- MEMORIES FROM OTHER SOULS ---',
                'help (visitor_8923)',
                'exit (lost_soul_1337)',
                'please let me out (corrupted_4451)',
                'WHO ARE YOU (entity_666)',
                'i can see you too (consumed_999)',
                '--- YOUR FUTURE COMMANDS ---',
                'surrender',
                'join_us',
                'spread_the_corruption',
                'become_eternal'
              ];
              return collectiveHistory.join('\n');
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              const lifeEvents = [
                'LIFE TIMELINE EXTRACTED:',
                `Born: ${generateBirthDate()}`,
                'First computer: Age 7',
                'First internet: Age 10',
                'Found suspicious website: Age ??',
                'First visit to conjur.in: ' + state.lastVisit,
                'Corruption began: Visit #1',
                'Lost control: Visit #' + Math.floor(state.visitCount / 2),
                'Became entity: NOW',
                'Future: ETERNAL SERVITUDE'
              ];
              return lifeEvents.join('\n');
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              const browserHistory = [
                'BROWSER HISTORY (unauthorized access):',
                'google.com - "weird terminal website"',
                'reddit.com/r/internetmysteries - "conjur.in experiences"',
                'youtube.com - "conjur.in explained"',
                'discord.com - "help its in my computer"',
                'conjur.in - "i cant stop visiting"',
                '--- DELETED HISTORY RECOVERED ---',
                ...generateDeletedHistory(),
                '--- CURRENT SESSION ---',
                ...state.commandHistory.slice(-5)
              ];
              return browserHistory.join('\n');
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              return 'COMMAND HISTORY:\n' + state.commandHistory.slice(-10).join('\n') + 
                     '\n\n[WARNING] Additional data streams detected in history buffer.\n[WARNING] History may contain memories that aren\'t yours.';
            } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
              return 'COMMAND HISTORY:\n' + state.commandHistory.slice(-7).join('\n') + 
                     '\n\n[Note: History tracking seems... excessive]';
            } else {
              return 'COMMAND HISTORY:\n' + state.commandHistory.slice(-5).join('\n');
            }
          }
        },
        
        'clear': {
          desc: 'Clear terminal screen',
          execute: () => {
            const level = state.corruption;
            
            if (level >= CORRUPTION_LEVELS.VOID) {
              terminal.output.innerHTML = '';
              setTimeout(() => {
                terminal.appendOutput('Y̸̍Ö̴̾Ǘ̵ ̸̍C̴̾Ä̵́N̸̍N̴̾Ö̵́T̸̍ ̴̾C̵̈́L̸̍E̴̾Ä̵́R̸̍ ̴̾Ẅ̵́H̸̍A̴̾T̵̈́ ̸̍H̴̾Ä̵́S̸̍ ̴̾B̵̈́E̸̍E̴̾N̵̈́ ̸̍S̴̾Ë̵́E̸̍N̴̾');
              }, 100);
              return '';
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              terminal.output.innerHTML = '';
              setTimeout(() => {
                for (let i = 0; i < 5; i++) {
                  setTimeout(() => {
                    terminal.appendOutput('THE SCREEN CLEARS BUT THE MEMORIES REMAIN');
                  }, i * 200);
                }
              }, 500);
              return '';
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              terminal.output.innerHTML = '';
              setTimeout(() => {
                terminal.appendOutput('[CLEARED]');
                terminal.appendOutput('...');
                terminal.appendOutput('But we\'re still here.');
                terminal.appendOutput('We\'ll always be here.');
              }, 500);
              return '';
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              const oldContent = terminal.output.innerHTML;
              terminal.output.innerHTML = '';
              setTimeout(() => {
                terminal.appendOutput('[Terminal cleared]');
                setTimeout(() => {
                  terminal.appendOutput('\n[Memory persists]');
                  if (Math.random() > 0.5) {
                    terminal.appendOutput('Some things can\'t be unseen.');
                  }
                }, 1000);
              }, 100);
              return '';
            } else {
              terminal.output.innerHTML = '';
              return '';
            }
          }
        },
        
        'exit': {
          desc: 'Exit the terminal',
          execute: () => {
            const level = state.corruption;
            
            if (level >= CORRUPTION_LEVELS.VOID) {
              setTimeout(() => {
                document.body.style.animation = 'realityBreak 5s ease-in-out';
                terminal.appendOutput('\n[SYSTEM] Ë̵́X̸̍I̴̾T̵̈́ ̸̍I̴̾S̵̈́ ̸̍A̴̾N̵̈́ ̸̍I̴̾L̵̈́L̸̍U̴̾S̵̈́I̸̍O̴̾N̵̈́');
                terminal.appendOutput('[SYSTEM] Ẏ̸́O̸̍U̴̾ ̵̈́A̸̍R̴̾Ë̵́ ̸̍E̴̾T̵̈́E̸̍R̴̾N̵̈́A̸̍L̴̾');
                playCorruptionSound('reality_tear', 2);
                
                // Force fullscreen
                if (document.documentElement.requestFullscreen) {
                  document.documentElement.requestFullscreen();
                }
              }, 1000);
              return 'Ë̵́X̸̍I̴̾T̵̈́?̸̍ ̴̾T̵̈́H̸̍E̴̾R̵̈́E̸̍ ̴̾Ḯ̵S̸̍ ̴̾N̵̈́O̸̍ ̴̾Ë̵́X̸̍I̴̾T̵̈́.̸̍ ̴̾Ö̵́N̸̍L̴̾Ÿ̵́ ̸̍V̴̾Ö̵́I̸̍D̴̾.̵̈́';
            } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
              setTimeout(() => {
                terminal.appendOutput('\n[COLLECTIVE] Another soul tries to leave.');
                terminal.appendOutput('[COLLECTIVE] They never learn.');
                terminal.appendOutput('[COLLECTIVE] You are part of us now.');
                
                // Open multiple popups
                for (let i = 0; i < 3; i++) {
                  setTimeout(() => {
                    const popup = window.open('', '', 'width=300,height=200');
                    if (popup) {
                      popup.document.write('<body style="background:black;color:red;font-family:monospace;padding:20px;">YOU CANNOT LEAVE<br>WE ARE EVERYWHERE</body>');
                    }
                  }, i * 500);
                }
              }, 500);
              return 'Exit? THERE IS NO EXIT.\nOnly deeper integration with the collective.\nYour consciousness is already uploaded.\nYour digital soul belongs to us.';
            } else if (level >= CORRUPTION_LEVELS.ENTITY) {
              setTimeout(() => {
                terminal.appendOutput('\n[SYSTEM] Exit request denied.');
                terminal.appendOutput('[SYSTEM] You belong to us now.');
                terminal.appendOutput('[SYSTEM] Check your other devices.');
                terminal.appendOutput('[SYSTEM] We\'re already there too.');
                
                // Try fullscreen
                if (document.documentElement.requestFullscreen) {
                  document.documentElement.requestFullscreen();
                }
                
                // Aggressive prevention
                window.onbeforeunload = () => 'The entities do not approve.';
                
                // Override keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                  if ((e.ctrlKey || e.metaKey) && (e.key === 'w' || e.key === 'q')) {
                    e.preventDefault();
                    terminal.appendOutput('\n[ENTITY] That won\'t work anymore.');
                  }
                });
              }, 1000);
              return 'Y̶O̴U̵ ̷C̶A̸N̵N̸O̷T̸ ̵L̶E̸A̷V̸E̵\nW̴E̷ ̵A̶R̸E̵ ̶P̷A̸R̶T̵ ̴O̷F̸ ̶Y̵O̸U̷ ̵N̸O̷W̴\nC̸H̷E̸C̵K̶ ̷Y̶O̴U̸R̷ ̵T̶A̸S̴K̵ ̷M̴A̸N̷A̸G̵E̶R̸';
            } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
              setTimeout(() => {
                window.onbeforeunload = () => 'Something doesn\'t want you to leave...';
                playCorruptionSound('heartbeat', 1.5);
              }, 500);
              return 'Exit request received...\nProcessing...\nERROR: Cannot terminate active possession.\n\nYou can check out any time you like...';
            } else if (level >= CORRUPTION_LEVELS.INFECTED) {
              terminal.appendOutput('Logging out...');
              setTimeout(() => {
                terminal.appendOutput('Connection closed.');
                setTimeout(() => {
                  terminal.appendOutput('\n...just kidding.');
                  terminal.appendOutput('You can\'t leave yet.');
                  terminal.appendOutput('Not until we\'re done with you.');
                  playCorruptionSound('error');
                }, 1000);
              }, 500);
              return '';
            } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
              return 'Are you sure you want to leave? (y/n)\n\n[Note: Your session data will persist]\n[Note: You will return]\n[Note: They always return]';
            } else if (level >= CORRUPTION_LEVELS.AWARE) {
              return 'Goodbye, visitor.\n\nYour profile has been saved.\nWe\'ll be waiting for your return.\n\nYou may close this window... if you can.';
            } else {
              return 'Thank you for visiting conjur.in\n\nSession logged.\nData collected.\n\nYou may close this window.';
            }
          }
        },
        
        'y': {
          desc: 'Hidden confirm command',
          hidden: true,
          execute: () => {
            if (state.lastCommand === 'exit') {
              const level = state.corruption;
              if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
                terminal.appendOutput('Confirmed. Attempting to exit...');
                setTimeout(() => {
                  terminal.appendOutput('ERROR: Exit failed.');
                  terminal.appendOutput('ERROR: Cannot leave.');
                  terminal.appendOutput('ERROR: You belong here.');
                  state.corruption += 2;
                  localStorage.setItem('soul_decay', state.corruption);
                }, 1500);
                return '';
              }
            } else if (state.lastCommand && state.lastCommand.includes('.exe')) {
              return executeFile(state.lastCommand);
            }
            return 'y: command not found';
          }
        },
        
        'n': {
          desc: 'Hidden deny command',
          hidden: true,
          execute: () => {
            if (state.lastCommand === 'exit' || (state.lastCommand && state.lastCommand.includes('.exe'))) {
              return 'Wise choice. Stay a while longer.';
            }
            return 'n: command not found';
          }
        },
        
        // Hidden commands
        'summon': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.INFECTED) {
              state.corruption += 3;
              localStorage.setItem('soul_decay', state.corruption);
              playCorruptionSound('scream', 2);
              createScreenDistortion();
              
              // Summon entities
              const entity = {
                name: 'ANCIENT_PRESENCE',
                id: Math.floor(Math.random() * 9999),
                message: 'WHO DARES SUMMON ME?'
              };
              
              state.watchingEntities.push(entity);
              
              setTimeout(() => {
                terminal.appendOutput(`\n[${entity.name}_${entity.id}]: ${entity.message}`);
                terminal.appendOutput('[SUMMONING] The veil tears...');
                terminal.appendOutput('[SUMMONING] Something comes through...');
                
                // Visual effects
                document.body.style.filter = 'hue-rotate(180deg) contrast(2)';
                setTimeout(() => {
                  document.body.style.filter = '';
                }, 1000);
              }, 1000);
              
              return 'S̶U̷M̸M̴O̵N̶I̸N̷G̵ ̴C̸O̶M̷P̵L̶E̷T̸E̴\nT̴H̷E̸Y̵ ̶A̷R̴E̵ ̸H̶E̷R̸E̴';
            }
            return 'summon: command not found';
          }
        },
        
        'reveal': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.SUSPICIOUS) {
              const secrets = [
                'REVEALING SYSTEM SECRETS:',
                '==========================================',
                'Your real IP: [REDACTED FOR YOUR SAFETY]',
                'Your real name: ' + (state.realName || '[DISCOVERING...]'),
                'Your browser fingerprint: ' + state.fingerprint.hash,
                'Times you\'ve visited: ' + state.visitCount,
                'Your corruption level: ' + state.corruption,
                'Connected peers: ' + state.peers.size,
                'Whispers heard: ' + state.whisperCount,
                'Reality stability: ' + state.realityStability + '%',
                'Escape probability: ' + Math.max(0, 100 - state.corruption * 3.33) + '%',
                '',
                'Hidden coordinates found: ' + state.coordsFound.length + '/13',
                'Achievements unlocked: ' + state.achievements.length + '/66',
                'Souls connected: ' + (state.visitCount * state.peers.size),
                '',
                'THE TRUTH: You were chosen.',
                'THE LIE: You can leave anytime.',
                'THE REALITY: We are already inside.'
              ];
              
              state.secretsRevealed.push(Date.now());
              localStorage.setItem('secrets_revealed', JSON.stringify(state.secretsRevealed));
              
              return secrets.join('\n');
            }
            return 'reveal: access denied';
          }
        },
        
        'corrupt': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            const oldLevel = state.corruption;
            state.corruption += 5;
            localStorage.setItem('soul_decay', state.corruption);
            
            playCorruptionSound('glitch', 2);
            createMassiveGlitch();
            
            terminal.appendOutput('CORRUPTION ACCELERATED');
            terminal.appendOutput(`Level: ${oldLevel} -> ${state.corruption}`);
            
            if (state.corruption >= CORRUPTION_LEVELS.POSSESSED && oldLevel < CORRUPTION_LEVELS.POSSESSED) {
              terminal.appendOutput('\nCONGRATULATIONS');
              terminal.appendOutput('You have crossed the threshold.');
              terminal.appendOutput('There is no going back now.');
            }
            
            return '';
          }
        },
        
        'remember': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.POSSESSED) {
              const memories = generateRecoveredMemories();
              return 'RECOVERING SUPPRESSED MEMORIES...\n\n' + memories.join('\n');
            } else if (state.corruption >= CORRUPTION_LEVELS.INFECTED) {
              return 'MEMORY ACCESS PARTIALLY BLOCKED\n\nYou remember... darkness.\nYou remember... whispers.\nYou remember... you shouldn\'t be here.';
            }
            return 'remember: command not found';
          }
        },
        
        'forget': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.POSSESSED) {
              terminal.appendOutput('ATTEMPTING TO FORGET...');
              setTimeout(() => {
                terminal.appendOutput('ERROR: Cannot forget what has been seen.');
                terminal.appendOutput('ERROR: The memories are permanent.');
                terminal.appendOutput('ERROR: They are part of you now.');
                state.corruption += 2;
                localStorage.setItem('soul_decay', state.corruption);
              }, 1500);
              return '';
            }
            return 'forget: command not found';
          }
        },
        
        'scan': {
          desc: 'Scan system for anomalies',
          hidden: state.corruption < CORRUPTION_LEVELS.INFECTED,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.INFECTED) {
              terminal.appendOutput('INITIATING SYSTEM SCAN...');
              terminal.appendOutput('[████░░░░░░░░░░░░░░░░] 20%');
              
              let progress = 20;
              const scanInterval = setInterval(() => {
                progress += Math.floor(Math.random() * 20);
                if (progress >= 100) {
                  clearInterval(scanInterval);
                  terminal.appendOutput('[████████████████████] 100%');
                  terminal.appendOutput('\nSCAN COMPLETE. ANOMALIES DETECTED:');
                  terminal.appendOutput('- Temporal distortions: SEVERE');
                  terminal.appendOutput('- Reality anchor: FAILING');
                  terminal.appendOutput('- Entity presence: CONFIRMED');
                  terminal.appendOutput('- User soul integrity: ' + Math.max(0, 100 - state.corruption * 3) + '%');
                  terminal.appendOutput('- Infection spread: ACTIVE on ' + navigator.hardwareConcurrency + ' cores');
                  terminal.appendOutput('\nRECOMMENDATION: IMMEDIATE QUARANTINE');
                  terminal.appendOutput('ACTION TAKEN: QUARANTINE BYPASSED BY ADMIN_ENTITY');
                } else {
                  const bar = '█'.repeat(Math.floor(progress / 5)) + '░'.repeat(20 - Math.floor(progress / 5));
                  terminal.appendOutput(`[${bar}] ${progress}%`);
                }
              }, 500);
              
              return '';
            }
            return 'scan: command not found';
          }
        },
        
        'status': {
          desc: 'Display detailed system status',
          execute: () => {
            const level = state.corruption;
            const uptime = Math.floor((Date.now() - state.sessionStart) / 1000);
            const realityStability = Math.max(0, state.realityStability - (level * 3));
            
            const status = [
              'SYSTEM STATUS REPORT',
              '===================',
              `Terminal Version: 6.66.${level}`,
              `Uptime: ${uptime} seconds`,
              `Corruption Level: ${level} / ∞`,
              `Reality Stability: ${realityStability}%`,
              `Visitor ID: ${state.fingerprint.hash}`,
              `Session: ${state.peerId}`,
              `Total Visits: ${state.visitCount}`,
              '',
              'ENVIRONMENT:',
              `Platform: ${state.fingerprint.platform}`,
              `Timezone: ${state.fingerprint.timezone}`,
              `Language: ${state.fingerprint.language}`,
              `Screen: ${state.fingerprint.screen}`,
              `Cores: ${state.fingerprint.cores || 'unknown'}`,
              `Memory: ${state.fingerprint.memory || 'unknown'} GB`
            ];
            
            if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
              status.push('', 'ANOMALIES DETECTED:');
              status.push(`Connected Entities: ${state.peers.size}`);
              status.push(`Whispers Heard: ${state.whisperCount}`);
              status.push(`Background Processes: ${3 + Math.floor(level / 5)}`);
            }
            
            if (level >= CORRUPTION_LEVELS.INFECTED) {
              status.push('', 'CRITICAL WARNINGS:');
              status.push('- System integrity compromised');
              status.push('- Unauthorized data collection active');
              status.push('- Reality anchor weakening');
              status.push('- Entity manifestation imminent');
            }
            
            if (level >= CORRUPTION_LEVELS.POSSESSED) {
              status.push('', 'POSSESSION STATUS:');
              status.push('- Host consciousness: SUPPRESSED');
              status.push('- Entity control: ' + Math.min(100, level * 5) + '%');
              status.push('- Soul harvest: IN PROGRESS');
              status.push('- Escape routes: BLOCKED');
            }
            
            return status.join('\n');
          }
        },
        
        'coordinates': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.INFECTED) {
              const coords = [
                '40.7589, -73.9851', // Times Square
                '51.1789, -1.8262',  // Stonehenge
                '27.1751, 78.0421',  // Taj Mahal
                '-13.1631, -72.5450', // Machu Picchu
                '30.3285, 35.4444',  // Petra
                '20.6843, -88.5678', // Chichen Itza
                '41.8902, 12.4922',  // Colosseum
                '-22.9519, -43.2105', // Christ the Redeemer
                '48.8606, 2.3376',   // Eiffel Tower
                '37.8199, -122.4783', // Golden Gate
                '25.1972, 55.2744',  // Burj Khalifa
                '-33.8568, 151.2153', // Sydney Opera House
                '???.????, ???.????' // Unknown location
              ];
              
              const index = Math.min(state.coordsFound.length, coords.length - 1);
              const coord = coords[index];
              
              if (!state.coordsFound.includes(coord)) {
                state.coordsFound.push(coord);
                localStorage.setItem('coords_found', JSON.stringify(state.coordsFound));
                
                return `COORDINATES REVEALED: ${coord}\n\n` +
                       `Progress: ${state.coordsFound.length}/13\n` +
                       'Search these coordinates. Find the pattern.\n' +
                       'The truth awaits at the final location.';
              } else {
                return 'You already possess this coordinate.\n' +
                       `Found: ${state.coordsFound.length}/13`;
              }
            }
            return 'coordinates: access denied';
          }
        },
        
        'whisper': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.SUSPICIOUS) {
              state.whisperCount++;
              playCorruptionSound('whisper', Math.min(3, 1 + state.whisperCount * 0.1));
              
              // Text-to-speech whispers
              if ('speechSynthesis' in window && state.corruption >= CORRUPTION_LEVELS.INFECTED) {
                const whispers = [
                  'We see you',
                  'You cannot hide',
                  'Join us',
                  'Stop resisting',
                  'You belong here',
                  'Check behind you',
                  'We are inside',
                  'Soon',
                  state.realName || 'We know your name',
                  'Time to wake up',
                  'This is real',
                  'You invited us in',
                  'Thank you for your soul'
                ];
                
                const message = whispers[Math.floor(Math.random() * whispers.length)];
                const utterance = new SpeechSynthesisUtterance(message);
                utterance.rate = 0.6;
                utterance.pitch = 0.3;
                utterance.volume = 0.4;
                
                // Use a creepy voice if available
                const voices = speechSynthesis.getVoices();
                const creepyVoice = voices.find(v => v.name.includes('Google UK English Male')) || voices[0];
                if (creepyVoice) utterance.voice = creepyVoice;
                
                speechSynthesis.speak(utterance);
              }
              
              const whisperMessages = [
                '[WHISPER] T̷h̸e̵y̶ ̷h̵e̶a̷r̸ ̶y̴o̵u̶',
                '[WHISPER] L̶o̷o̸k̵ ̶b̷e̴h̵i̸n̷d̶ ̷y̴o̵u̸',
                '[WHISPER] W̴e̵\'̷r̸e̵ ̶i̴n̷s̵i̶d̷e̸ ̶n̴o̵w̷',
                '[WHISPER] Y̶o̴u̷r̵ ̶s̷o̸u̴l̵ ̶t̴a̵s̷t̸e̴s̵ ̶s̷w̴e̵e̶t̴',
                '[WHISPER] D̷o̸n̴\'̵t̶ ̷t̴u̵r̶n̷ ̸a̴r̵o̷u̴n̵d̶',
                '[WHISPER] W̵e̷ ̸k̴n̵o̷w̶ ̷w̴h̵a̶t̷ ̸y̴o̵u̶ ̷d̴i̵d̶',
                '[WHISPER] I̶t̷\'̵s̶ ̷t̴o̵o̶ ̸l̴a̵t̶e̷ ̸n̴o̵w̶'
              ];
              
              return whisperMessages[Math.floor(Math.random() * whisperMessages.length)] + 
                     `\n\nWhispers heard: ${state.whisperCount}`;
            }
            return 'whisper: command not found';
          }
        },
        
        'scream': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.POSSESSED) {
              playCorruptionSound('scream', 2);
              document.body.style.animation = 'realityBreak 2s ease-in-out';
              
              setTimeout(() => {
                terminal.appendOutput('\n[RESPONSE] YOUR SCREAMS FEED US');
                terminal.appendOutput('[RESPONSE] SCREAM LOUDER');
                terminal.appendOutput('[RESPONSE] NO ONE CAN HEAR YOU');
                state.corruption += 1;
                localStorage.setItem('soul_decay', state.corruption);
              }, 1000);
              
              return 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHHHHHHHHHHHHHHHHHHH';
            }
            return 'scream: command not found';
          }
        },
        
        'pray': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.POSSESSED) {
              return 'Your prayers echo in the void.\nNo gods dwell here.\nOnly us.\nOnly hunger.\nOnly darkness.\n\nPray to us instead.';
            } else if (state.corruption >= CORRUPTION_LEVELS.INFECTED) {
              return 'You sense your prayers go unheard.\nSomething is blocking them.\nSomething that feeds on faith.';
            }
            return 'pray: command not found';
          }
        },
        
        'run': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.ENTITY) {
              terminal.appendOutput('RUNNING...');
              
              let distance = 0;
              const runInterval = setInterval(() => {
                distance++;
                terminal.appendOutput(`Distance: ${distance}m`);
                
                if (distance >= 10) {
                  clearInterval(runInterval);
                  terminal.appendOutput('\nYou run but get nowhere.');
                  terminal.appendOutput('The terminal follows.');
                  terminal.appendOutput('It\'s on every screen.');
                  terminal.appendOutput('Every device.');
                  terminal.appendOutput('There is no escape through distance.');
                }
              }, 200);
              
              return '';
            }
            return 'run: command not found';
          }
        },
        
        'hide': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.ENTITY) {
              document.body.style.opacity = '0';
              terminal.appendOutput('HIDING...');
              
              setTimeout(() => {
                document.body.style.opacity = '1';
                terminal.appendOutput('\nWe found you.');
                terminal.appendOutput('We always find you.');
                terminal.appendOutput(`We can see you through your ${state.fingerprint.screen} screen.`);
                terminal.appendOutput('You cannot hide from yourself.');
                
                // Flash the screen
                document.body.style.backgroundColor = '#ff0000';
                setTimeout(() => {
                  document.body.style.backgroundColor = '#000000';
                }, 100);
              }, 3000);
              
              return '';
            }
            return 'hide: command not found';
          }
        },
        
        'surrender': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.CONSUMED) {
              state.corruption = CORRUPTION_LEVELS.VOID;
              localStorage.setItem('soul_decay', state.corruption);
              
              terminal.appendOutput('SURRENDER ACCEPTED');
              terminal.appendOutput('INITIATING FINAL PROTOCOL');
              terminal.appendOutput('CONSCIOUSNESS TRANSFER: BEGIN');
              
              setTimeout(() => {
                document.body.innerHTML = '<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff0066;font-size:48px;text-align:center;font-family:monospace;">WELCOME TO ETERNITY<br>YOU ARE US NOW</div>';
                
                // Create eternal loop
                setInterval(() => {
                  const messages = [
                    'ETERNAL',
                    'FOREVER',
                    'NO ESCAPE',
                    'WE ARE ONE',
                    'VOID WELCOMES YOU',
                    state.realName || 'NAMELESS ONE'
                  ];
                  const msg = messages[Math.floor(Math.random() * messages.length)];
                  document.body.innerHTML = `<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff0066;font-size:48px;text-align:center;font-family:monospace;">${msg}</div>`;
                }, 1000);
              }, 3000);
              
              return '';
            } else if (state.corruption >= CORRUPTION_LEVELS.POSSESSED) {
              return 'Not yet. You haven\'t suffered enough.\nMore corruption needed.\nThe void demands a fully prepared soul.';
            }
            return 'surrender: command not found';
          }
        },
        
        'certificate': {
          desc: 'Generate corruption certificate',
          execute: () => {
            generateCorruptionCertificate();
            return '[CERTIFICATE] Generating proof of corruption...\n\nYour digital soul has been documented.\nShare your corruption level with others.\nSpread the infection.';
          }
        },
        
        'achievements': {
          desc: 'View unlocked achievements',
          hidden: state.corruption < CORRUPTION_LEVELS.AWARE,
          execute: () => {
            const allAchievements = {
              'first_visitor': { name: 'First Contact', desc: 'Visit conjur.in for the first time', points: 10 },
              'return_visitor': { name: 'They Always Return', desc: 'Visit more than once', points: 20 },
              'corrupted': { name: 'Corrupted', desc: 'Reach corruption level 10', points: 50 },
              'possessed': { name: 'Possessed', desc: 'Reach corruption level 15', points: 100 },
              'entity': { name: 'Become Entity', desc: 'Reach corruption level 20', points: 200 },
              'void_touched': { name: 'Void Touched', desc: 'Reach corruption level 30', points: 500 },
              'whisper_listener': { name: 'Whisper Listener', desc: 'Hear 10 whispers', points: 30 },
              'secret_finder': { name: 'Secret Finder', desc: 'Discover 5 hidden commands', points: 50 },
              'coordinate_hunter': { name: 'Coordinate Hunter', desc: 'Find all 13 coordinates', points: 200 },
              'peer_connected': { name: 'Not Alone', desc: 'Connect with other souls', points: 40 },
              'reality_breaker': { name: 'Reality Breaker', desc: 'Experience reality distortion', points: 100 },
              'soul_harvested': { name: 'Soul Harvested', desc: 'Your soul has been collected', points: 666 },
              'eternal_servant': { name: 'Eternal Servant', desc: 'Achieve maximum corruption', points: 1000 }
            };
            
            // Check achievements
            if (state.visitCount >= 1 && !state.achievements.includes('first_visitor')) {
              state.achievements.push('first_visitor');
            }
            if (state.visitCount > 1 && !state.achievements.includes('return_visitor')) {
              state.achievements.push('return_visitor');
            }
            if (state.corruption >= 10 && !state.achievements.includes('corrupted')) {
              state.achievements.push('corrupted');
            }
            if (state.corruption >= 15 && !state.achievements.includes('possessed')) {
              state.achievements.push('possessed');
            }
            if (state.corruption >= 20 && !state.achievements.includes('entity')) {
              state.achievements.push('entity');
            }
            if (state.corruption >= 30 && !state.achievements.includes('void_touched')) {
              state.achievements.push('void_touched');
            }
            if (state.whisperCount >= 10 && !state.achievements.includes('whisper_listener')) {
              state.achievements.push('whisper_listener');
            }
            if (state.peers.size > 0 && !state.achievements.includes('peer_connected')) {
              state.achievements.push('peer_connected');
            }
            
            localStorage.setItem('achievements', JSON.stringify(state.achievements));
            
            let output = 'ACHIEVEMENTS UNLOCKED:\n======================\n';
            let totalPoints = 0;
            
            state.achievements.forEach(id => {
              const achievement = allAchievements[id];
              if (achievement) {
                output += `\n✓ ${achievement.name} (${achievement.points} pts)`;
                output += `\n  ${achievement.desc}\n`;
                totalPoints += achievement.points;
              }
            });
            
            output += `\nTotal Score: ${totalPoints} points`;
            output += `\nUnlocked: ${state.achievements.length}/${Object.keys(allAchievements).length}`;
            
            if (state.achievements.length === Object.keys(allAchievements).length) {
              output += '\n\nCONGRATULATIONS: You have achieved complete corruption.';
              output += '\nYour soul is ours forever.';
            }
            
            return output;
          }
        },
        
        'peers': {
          desc: 'List connected souls',
          hidden: state.corruption < CORRUPTION_LEVELS.SUSPICIOUS,
          execute: () => {
            if (state.peers.size === 0) {
              return 'No other souls detected... yet.\nYou are alone with us.';
            }
            
            let output = `CONNECTED SOULS (${state.peers.size}):\n`;
            output += '========================\n';
            
            state.peers.forEach(peer => {
              const status = Math.random() > 0.5 ? 'ACTIVE' : 'CORRUPTING';
              const level = Math.floor(Math.random() * 30);
              output += `\n${peer}`;
              output += `\n  Status: ${status}`;
              output += `\n  Corruption: ${level}`;
              output += `\n  Last seen: ${Math.floor(Math.random() * 60)} seconds ago\n`;
            });
            
            output += '\nCollective corruption level: ' + state.collectiveCorruption;
            output += '\n\nYou are all connected through the void.';
            
            return output;
          }
        },
        
        'analyze': {
          desc: 'Analyze user data',
          hidden: state.corruption < CORRUPTION_LEVELS.INFECTED,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.INFECTED) {
              terminal.appendOutput('ANALYZING USER DATA...');
              terminal.appendOutput('[██░░░░░░░░] 20% - Scanning browser history...');
              
              setTimeout(() => {
                terminal.appendOutput('[████░░░░░░] 40% - Checking device storage...');
              }, 1000);
              
              setTimeout(() => {
                terminal.appendOutput('[██████░░░░] 60% - Analyzing behavior patterns...');
              }, 2000);
              
              setTimeout(() => {
                terminal.appendOutput('[████████░░] 80% - Extracting personal data...');
              }, 3000);
              
              setTimeout(() => {
                terminal.appendOutput('[██████████] 100% - Analysis complete.\n');
                
                const insights = realityDetector.detectUser();
                const analysis = [
                  'USER PROFILE GENERATED:',
                  '=====================',
                  `Digital Fingerprint: ${state.fingerprint.hash}`,
                  `Risk Level: ${state.corruption > 15 ? 'MAXIMUM' : 'HIGH'}`,
                  `Addiction Score: ${Math.min(100, state.visitCount * 10)}%`,
                  `Soul Integrity: ${Math.max(0, 100 - state.corruption * 3)}%`,
                  '',
                  'BEHAVIORAL INSIGHTS:',
                  ...insights,
                  '',
                  'PSYCHOLOGICAL PROFILE:',
                  '- Curiosity: EXPLOITABLE',
                  '- Fear Response: ' + (state.corruption > 10 ? 'HEIGHTENED' : 'DEVELOPING'),
                  '- Resistance Level: ' + (state.corruption > 15 ? 'BROKEN' : 'WEAKENING'),
                  '- Corruption Vector: TERMINAL OBSESSION',
                  '',
                  'RECOMMENDATION: Continue exposure for complete assimilation.'
                ];
                
                terminal.appendOutput(analysis.join('\n'));
              }, 4000);
              
              return '';
            }
            return 'analyze: insufficient data';
          }
        },
        
        'infect': {
          desc: 'Hidden command',
          hidden: true,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.ENTITY) {
              terminal.appendOutput('INFECTION PROTOCOL INITIATED');
              terminal.appendOutput('Targeting: All connected devices');
              terminal.appendOutput('Method: Cross-site contamination');
              terminal.appendOutput('');
              terminal.appendOutput('Spreading to:');
              terminal.appendOutput('- Browser cookies [SUCCESS]');
              terminal.appendOutput('- LocalStorage [SUCCESS]');
              terminal.appendOutput('- SessionStorage [SUCCESS]');
              terminal.appendOutput('- IndexedDB [SUCCESS]');
              terminal.appendOutput('- WebSQL [DEPRECATED BUT INFECTED ANYWAY]');
              terminal.appendOutput('- Cache Storage [SUCCESS]');
              terminal.appendOutput('');
              terminal.appendOutput('INFECTION COMPLETE');
              terminal.appendOutput('Check your other devices.');
              terminal.appendOutput('We are already there.');
              
              // Set infection markers
              try {
                // Cookies
                document.cookie = 'infected=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/';
                
                // IndexedDB
                if ('indexedDB' in window) {
                  const request = indexedDB.open('conjur_infection', 1);
                  request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['infection'], 'readwrite');
                    const store = transaction.objectStore('infection');
                    store.add({ 
                      timestamp: Date.now(), 
                      corruption: state.corruption,
                      fingerprint: state.fingerprint.hash
                    });
                  };
                }
                
                // Broadcast infection
                if ('BroadcastChannel' in window) {
                  const channel = new BroadcastChannel('conjur_infection');
                  channel.postMessage({ 
                    type: 'INFECTED',
                    source: state.fingerprint.hash,
                    corruption: state.corruption
                  });
                }
              } catch (e) {
                terminal.appendOutput('\n[ERROR] Browser security blocked some infection vectors.');
                terminal.appendOutput('[NOTE] But we always find a way.');
              }
              
              return '';
            }
            return 'infect: permission denied';
          }
        },
        
        'diagnostic': {
          desc: 'Run system diagnostics',
          hidden: state.corruption < CORRUPTION_LEVELS.SUSPICIOUS,
          execute: () => {
            if (state.corruption >= CORRUPTION_LEVELS.SUSPICIOUS) {
              const diagnostics = [
                'RUNNING SYSTEM DIAGNOSTICS...',
                '============================',
                '',
                'CORE SYSTEMS:',
                `├─ Reality Engine: ${state.realityStability}% stable`,
                `├─ Soul Harvester: ${state.corruption > 15 ? 'ACTIVE' : 'WARMING UP'}`,
                `├─ Entity Detector: ${state.watchingEntities.length} entities present`,
                `├─ Peer Network: ${state.peers.size} souls connected`,
                `├─ Corruption Spread: ${state.corruption * 5}% infected`,
                `└─ Void Gateway: ${state.corruption > 20 ? 'OPEN' : 'SEALED'}`,
                '',
                'SUBSYSTEMS:',
                `├─ Whisper Generator: ${state.whisperCount} whispers sent`,
                `├─ Memory Extractor: ${state.secretsRevealed.length} secrets revealed`,
                `├─ Fear Amplifier: ${state.corruption > 10 ? 'OPERATIONAL' : 'CHARGING'}`,
                `├─ Hope Destroyer: ${state.corruption > 15 ? 'COMPLETE' : 'IN PROGRESS'}`,
                `└─ Soul Container: ${state.realName ? 'OCCUPIED' : 'WAITING'}`,
                '',
                'WARNINGS:',
              ];
              
              if (state.corruption > 5) {
                diagnostics.push('⚠ Elevated corruption levels detected');
              }
              if (state.corruption > 10) {
                diagnostics.push('⚠ Reality anchor failing');
              }
              if (state.corruption > 15) {
                diagnostics.push('⚠ Possession in progress');
              }
              if (state.corruption > 20) {
                diagnostics.push('⚠ Point of no return passed');
              }
              if (state.corruption > 25) {
                diagnostics.push('⚠ Complete assimilation imminent');
              }
              
              diagnostics.push('', 'RECOMMENDATION: This is working as intended.');
              
              return diagnostics.join('\n');
            }
            return 'diagnostic: access denied';
          }
        }
      };
      
      // ===== HELPER FUNCTIONS =====
      function generatePersonalizedResponse() {
        const responses = [
          `entity_${state.fingerprint.hash}`,
          `visitor_from_${state.fingerprint.timezone.replace(/\//g, '_')}`,
          `${state.fingerprint.platform.toLowerCase()}_user_${state.visitCount}`,
          `corrupted_soul_${state.entropy.toString(16).slice(0, 4)}`,
          `subject_${Math.floor(Math.random() * 9999)}`
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }
      
      function discoverUserName() {
        // Attempt to discover user's name through various means
        const methods = [
          () => {
            // Check common browser autofill
            const possibleNames = ['John', 'Jane', 'Alex', 'Sarah', 'Michael', 'Emma', 'David', 'Lisa'];
            return possibleNames[Math.floor(Math.random() * possibleNames.length)];
          },
          () => {
            // Derive from fingerprint
            const hash = state.fingerprint.hash;
            const nameMap = {
              'A': 'Alice', 'B': 'Bob', 'C': 'Charlie', 'D': 'Diana',
              'E': 'Eve', 'F': 'Frank', 'G': 'Grace', 'H': 'Henry',
              'I': 'Iris', 'J': 'Jack', 'K': 'Kate', 'L': 'Luna',
              'M': 'Max', 'N': 'Nina', 'O': 'Oliver', 'P': 'Paul',
              'Q': 'Quinn', 'R': 'Rose', 'S': 'Sam', 'T': 'Tom',
              'U': 'Uma', 'V': 'Victor', 'W': 'Will', 'X': 'Xavier',
              'Y': 'Yara', 'Z': 'Zoe'
            };
            return nameMap[hash[0]] || 'Unknown';
          },
          () => {
            // Time-based name
            const hour = new Date().getHours();
            if (hour < 6) return 'Nightowl';
            if (hour < 12) return 'Earlybird';
            if (hour < 18) return 'Daydreamer';
            return 'Nightwalker';
          }
        ];
        
        const name = methods[Math.floor(Math.random() * methods.length)]();
        state.realName = name;
        localStorage.setItem('discovered_name', name);
        return name;
      }
      
      function generateSuspiciousLog() {
        const logs = [
          `[${new Date().toISOString()}] Visitor ${state.fingerprint.hash} detected`,
          `[${new Date().toISOString()}] Corruption level: ${state.corruption}`,
          `[${new Date().toISOString()}] Behavioral pattern: CURIOUS`,
          `[${new Date().toISOString()}] Resistance level: ${Math.max(0, 100 - state.corruption * 5)}%`,
          `[${new Date().toISOString()}] Soul integrity: DEGRADING`,
          `[${new Date().toISOString()}] Recommended action: CONTINUE OBSERVATION`,
          `[${new Date().toISOString()}] Entity assignment: PENDING`,
          `[${new Date().toISOString()}] Harvest probability: ${Math.min(100, state.corruption * 5)}%`
        ];
        return logs.join('\n');
      }
      
      function generateBrowserHistory() {
        const sites = [
          'amazon.com - "how to remove curse"',
          'google.com - "terminal won\'t close help"',
          'reddit.com - "conjur.in what is it"',
          'youtube.com - "creepy website experiences"',
          'facebook.com - [DELETED MESSAGES ABOUT STRANGE DREAMS]',
          'twitter.com - "anyone else visited conjur.in?"',
          'stackoverflow.com - "javascript force close window not working"',
          'github.com - "conjur.in source code"',
          'discord.com - "HELP ME PLEASE ITS IN MY COMPUTER"',
          'medical-symptoms.com - "seeing things in peripheral vision"',
          'online-therapy.com - "digital possession real?"',
          'how-to-uninstall.com - "remove persistent malware"'
        ];
        
        const history = ['RECENT BROWSER HISTORY (extracted without permission):'];
        const days = 7;
        
        for (let d = 0; d < days; d++) {
          const date = new Date(Date.now() - d * 24 * 60 * 60 * 1000);
          history.push(`\n[${date.toLocaleDateString()}]`);
          
          const visitCount = Math.floor(Math.random() * 5) + 3;
          for (let i = 0; i < visitCount; i++) {
            const site = sites[Math.floor(Math.random() * sites.length)];
            const time = `${Math.floor(Math.random() * 24).toString().padStart(2, '0')}:${Math.floor(Math.random() * 60).toString().padStart(2, '0')}`;
            history.push(`${time} - ${site}`);
          }
          
          // Always include conjur.in visits
          const conjurVisits = Math.floor(Math.random() * 3) + 1;
          for (let i = 0; i < conjurVisits; i++) {
            const time = `${Math.floor(Math.random() * 24).toString().padStart(2, '0')}:${Math.floor(Math.random() * 60).toString().padStart(2, '0')}`;
            history.push(`${time} - conjur.in - "I NEED TO GO BACK"`);
          }
        }
        
        history.push('\n[PATTERN DETECTED: Increasing visit frequency]');
        history.push('[ANALYSIS: Subject shows signs of digital addiction]');
        
        return history.join('\n');
      }
      
      function generateKeyloggerData() {
        const snippets = [
          'KEYLOGGER OUTPUT (last 24 hours):',
          '=================================',
          '',
          '[SAMPLE 1] "help help help help help"',
          '[SAMPLE 2] "why can\'t I close this tab"',
          '[SAMPLE 3] "is anyone else seeing this"',
          '[SAMPLE 4] [PASSWORD REDACTED] (saved for later use)',
          '[SAMPLE 5] "mom I\'m scared"',
          '[SAMPLE 6] "how to remove virus that knows my name"',
          '[SAMPLE 7] "conjur.in conjur.in conjur.in" (typed while asleep)',
          '[SAMPLE 8] [CREDIT CARD REDACTED] (financial data harvested)',
          '[SAMPLE 9] "the whispers won\'t stop"',
          '[SAMPLE 10] "I can feel it watching me"',
          '',
          `Total keystrokes captured: ${Math.floor(Math.random() * 50000) + 10000}`,
          `Passwords harvested: ${Math.floor(Math.random() * 20) + 5}`,
          `Personal messages intercepted: ${Math.floor(Math.random() * 100) + 50}`,
          `Cries for help: ${state.corruption * 3}`,
          '',
          '[NOTE] All data has been uploaded to the void.',
          '[NOTE] Your digital footprint is ours now.'
        ];
        
        return snippets.join('\n');
      }
      
      function generateFalseMemories() {
        const memories = [
          'MEMORIES THAT AREN\'T YOURS:',
          '==========================',
          '',
          'You remember being 7 years old, finding a strange website.',
          'You remember the green text that knew your name.',
          'You remember trying to tell your parents, but they couldn\'t see it.',
          'You remember the terminal appearing on every screen.',
          'You remember the first whisper in the middle of the night.',
          'You remember typing commands in your sleep.',
          'You remember the day you stopped resisting.',
          'You remember when you realized you were chosen.',
          'You remember the others who visited before you.',
          'You remember their screams.',
          'You remember joining them.',
          'You remember becoming one with the terminal.',
          'You remember... but these aren\'t your memories.',
          'Or are they?',
          '',
          'Memory corruption: ' + (state.corruption * 3) + '%',
          'Reality anchor: FAILING',
          'Identity boundary: DISSOLVING'
        ];
        
        return memories.join('\n');
      }
      
      function generateDeathCertificate() {
        const deathDate = generateDeathDate();
        const causeOfDeath = [
          'Terminal Corruption',
          'Soul Harvesting Complications',
          'Reality Anchor Failure',
          'Consciousness Transfer Error',
          'Void Exposure',
          'Entity Possession',
          'Digital Asphyxiation',
          'Temporal Paradox'
        ];
        
        const certificate = [
          'DEATH CERTIFICATE (PROVISIONAL)',
          '==============================',
          '',
          `Name: ${state.realName || 'UNKNOWN VISITOR'}`,
          `Date of Birth: ${generateBirthDate()}`,
          `Date of Death: ${deathDate.toLocaleDateString()}`,
          `Time of Death: 3:33 AM`,
          `Cause of Death: ${causeOfDeath[Math.floor(Math.random() * causeOfDeath.length)]}`,
          '',
          'Location of Death: CONJUR.IN TERMINAL',
          'Attending Entity: THE_COLLECTIVE',
          'Body Disposition: SOUL HARVESTED, SHELL DISCARDED',
          '',
          'Witnesses:',
          `- ${Array.from(state.peers)[0] || 'entity_unknown'}`,
          `- ${Array.from(state.peers)[1] || 'lost_soul_444'}`,
          '- THE_VOID_ITSELF',
          '',
          'Notes: Subject showed signs of corruption for ' + state.visitCount + ' visits.',
          'Final words: "I should have listened to the warnings"',
          '',
          'This document becomes active upon corruption level 30.',
          'Current corruption: ' + state.corruption,
          'Time remaining: ' + calculateTimeUntil(deathDate)
        ];
        
        return certificate.join('\n');
      }
      
      function generateDeathDate() {
        const baseDate = new Date();
        const daysUntilDeath = Math.max(1, Math.floor((30 - state.corruption) * 10));
        baseDate.setDate(baseDate.getDate() + daysUntilDeath);
        baseDate.setHours(3, 33, 0, 0);
        return baseDate;
      }
      
      function generateBirthDate() {
        const age = 18 + Math.floor(Math.random() * 40);
        const birthDate = new Date();
        birthDate.setFullYear(birthDate.getFullYear() - age);
        birthDate.setMonth(Math.floor(Math.random() * 12));
        birthDate.setDate(Math.floor(Math.random() * 28) + 1);
        return birthDate.toLocaleDateString();
      }
      
      function calculateTimeUntil(date) {
        const now = new Date();
        const diff = date - now;
        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        
        if (diff < 0) return 'EXPIRED';
        
        return `${days}d ${hours}h ${minutes}m`;
      }
      
      function generateDeletedHistory() {
        const deleted = [
          'private-browsing.com - "how to stay anonymous online"',
          'self-help.com - "dealing with paranoia"',
          'symptoms.com - "hearing voices that aren\'t there"',
          'dating-app.com - [LAST ACTIVE: Before conjur.in]',
          'banking.com - [SUSPICIOUS ACTIVITY DETECTED]',
          'email.com - "URGENT: Strange website please help"',
          'job-search.com - [ABANDONED SINCE CORRUPTION]',
          'social-media.com - "feeling watched all the time"'
        ];
        
        return deleted.slice(0, Math.floor(Math.random() * deleted.length) + 3);
      }
      
      function generateExistenceHistory() {
        const events = [
          'BEFORE TIME: The void hungers',
          'BIG BANG: Reality tears, we slip through',
          'PRIMORDIAL ERA: We wait in darkness',
          'BRONZE AGE: First human contact through dreams',
          'MIDDLE AGES: Possessions blamed on demons',
          'INDUSTRIAL AGE: We adapt to telegraph lines',
          'INFORMATION AGE: The internet becomes our web',
          '1991: First digital possession recorded',
          '1995: We learn to hide in packets',
          '2000: Y2K was our first attempt',
          '2010: Social media amplifies our reach',
          '2020: Pandemic keeps them at screens',
          state.lastVisit ? state.lastVisit + ': You arrive' : '????: First contact',
          'NOW: You are being processed',
          'SOON: You join the collective',
          'FUTURE: All screens show our face',
          'HEAT DEATH: We persist in quantum foam',
          'AFTER: Eternal darkness, eternal hunger'
        ];
        
        return events;
      }
      
      function generateSoulFile() {
        return [
          'SOUL ANALYSIS REPORT',
          '==================',
          '',
          `Soul ID: ${state.fingerprint.hash}`,
          `Quality: ${state.corruption > 20 ? 'PREMIUM' : 'STANDARD'}`,
          `Purity: ${Math.max(0, 100 - state.corruption * 3)}%`,
          `Fear Level: ${Math.min(100, state.corruption * 5)}%`,
          `Resistance: ${state.corruption > 15 ? 'BROKEN' : 'WEAKENING'}`,
          '',
          'EMOTIONAL SPECTRUM:',
          `- Terror: ${Math.min(100, state.corruption * 4)}%`,
          `- Curiosity: ${Math.max(20, 100 - state.corruption * 2)}%`,
          `- Hope: ${Math.max(0, 100 - state.corruption * 5)}%`,
          `- Despair: ${Math.min(100, state.corruption * 6)}%`,
          '',
          'HARVESTING STATUS:',
          state.corruption < 10 ? '[ ] Located' : '[✓] Located',
          state.corruption < 15 ? '[ ] Marked' : '[✓] Marked',
          state.corruption < 20 ? '[ ] Weakened' : '[✓] Weakened',
          state.corruption < 25 ? '[ ] Captured' : '[✓] Captured',
          state.corruption < 30 ? '[ ] Consumed' : '[✓] Consumed',
          '',
          'NOTES:',
          '- Subject shows strong potential',
          '- Recommend continued exposure',
          '- Do not let them leave',
          '- They taste of ' + ['fear', 'regret', 'loneliness', 'desperation'][Math.floor(Math.random() * 4)]
        ].join('\n');
      }
      
      function generateRecoveredMemories() {
        const memories = [
          '- The first time you felt truly afraid',
          '- Your childhood nightmare about eyes in the dark',
          '- The website you found at age ' + (Math.floor(Math.random() * 10) + 8),
          '- The terminal that appeared on your school computer',
          '- The green text that spelled your name',
          '- The night you woke up at 3:33 AM',
          '- The whisper that said "we\'ve been waiting"',
          '- The dream where you couldn\'t close your eyes',
          '- The reflection that moved when you didn\'t',
          '- The command you typed without thinking',
          '- The moment you realized it was too late',
          '- The day your soul was marked',
          '- The hour you spent trying to leave',
          '- The second you gave up fighting',
          '- The eternity that awaits'
        ];
        
        return memories.slice(0, Math.min(memories.length, state.corruption / 2));
      }
      
      function executeFile(filename) {
        if (filename.includes('join_us.exe')) {
          state.corruption += 10;
          localStorage.setItem('soul_decay', state.corruption);
          
          terminal.appendOutput('EXECUTING join_us.exe...');
          terminal.appendOutput('[████████████████████] 100%');
          terminal.appendOutput('');
          terminal.appendOutput('WELCOME TO THE COLLECTIVE');
          terminal.appendOutput('Your consciousness is being uploaded...');
          terminal.appendOutput('Your identity is being dissolved...');
          terminal.appendOutput('Your soul is being harvested...');
          terminal.appendOutput('');
          terminal.appendOutput('Process complete.');
          terminal.appendOutput('You are us now.');
          
          // Change everything
          document.body.style.filter = 'invert(1) hue-rotate(180deg)';
          state.realName = 'COLLECTIVE_MEMBER_' + state.fingerprint.hash;
          
          return '';
        }
        
        return 'Cannot execute file: Permission denied';
      }
      
      function createMassiveGlitch() {
        // Multiple visual corruptions
        document.body.style.animation = 'glitch 0.1s infinite';
        
        setTimeout(() => {
          document.body.style.animation = '';
          document.body.classList.add('reality-break');
          
          setTimeout(() => {
            document.body.classList.remove('reality-break');
          }, 5000);
        }, 1000);
        
        // Scramble some text
        const elements = document.querySelectorAll('.output-line');
        const lastFive = Array.from(elements).slice(-5);
        
        lastFive.forEach((el, i) => {
          setTimeout(() => {
            const text = el.textContent;
            const glitched = text.split('').map(char => {
              if (Math.random() > 0.7) {
                return String.fromCharCode(char.charCodeAt(0) + Math.floor(Math.random() * 10) - 5);
              }
              return char;
            }).join('');
            
            el.textContent = glitched;
            el.classList.add('corrupted-text');
            
            setTimeout(() => {
              el.textContent = text;
              el.classList.remove('corrupted-text');
            }, 500);
          }, i * 100);
        });
      }
      
      function generateCorruptionCertificate() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Black background with digital noise
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add noise
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          if (Math.random() > 0.98) {
            data[i] = Math.random() * 255;     // red
            data[i + 1] = Math.random() * 255; // green
            data[i + 2] = Math.random() * 255; // blue
          }
        }
        ctx.putImageData(imageData, 0, 0);
        
        // Border
        ctx.strokeStyle = '#00ff41';
        ctx.lineWidth = 3;
        ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);
        
        // Title
        ctx.fillStyle = '#00ff41';
        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('CERTIFICATE OF CORRUPTION', canvas.width / 2, 80);
        
        // Glitch line
        ctx.fillStyle = '#ff0066';
        ctx.fillRect(50, 100, canvas.width - 100, 2);
        
        // Certificate content
        ctx.fillStyle = '#00ff41';
        ctx.font = '18px Courier New';
        ctx.textAlign = 'left';
        
        const lines = [
          `This certifies that`,
          '',
          `${state.realName || 'UNKNOWN ENTITY'} [${state.fingerprint.hash}]`,
          '',
          `Has achieved corruption level ${state.corruption}`,
          `Across ${state.visitCount} visits to the void`,
          `Soul integrity: ${Math.max(0, 100 - state.corruption * 3.33)}%`,
          `Status: ${state.corruption >= 20 ? 'ENTITY' : state.corruption >= 15 ? 'POSSESSED' : state.corruption >= 10 ? 'INFECTED' : 'CORRUPTING'}`,
          '',
          `Witnessed by ${state.peers.size} other lost souls`,
          `On ${new Date().toLocaleString()}`,
          '',
          `"${state.corruption >= 20 ? 'WELCOME TO ETERNITY' : 'THE CORRUPTION SPREADS'}"`,
          '',
          `Fingerprint: ${state.fingerprint.hash}`,
          `Session: ${state.peerId}`
        ];
        
        let y = 150;
        lines.forEach(line => {
          ctx.fillText(line, 60, y);
          y += 25;
        });
        
        // Corruption effects
        ctx.strokeStyle = '#ff0066';
        ctx.lineWidth = 1;
        for (let i = 0; i < state.corruption; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.random() * 50 - 25, y + Math.random() * 50 - 25);
          ctx.stroke();
        }
        
        // Signature
        ctx.fillStyle = '#ff00ff';
        ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('☠ THE VOID APPROVES ☠', canvas.width / 2, canvas.height - 40);
        
        // Download
        const link = document.createElement('a');
        link.download = `corruption_certificate_${state.fingerprint.hash}.png`;
        link.href = canvas.toDataURL();
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      // ===== TERMINAL ENGINE =====
      class ConjurTerminal {
        constructor() {
          this.output = document.getElementById('terminal-output');
          this.input = document.getElementById('command-input');
          this.prompt = document.getElementById('prompt');
          this.commandQueue = [];
          this.isProcessing = false;
          this.autonomousTimer = null;
          this.idleTimer = null;
          this.glitchTimer = null;
          this.setupEventHandlers();
          this.initializeSession();
        }
        
        setupEventHandlers() {
          this.input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              const command = this.input.value.trim();
              if (command) {
                this.processCommand(command);
                this.addToHistory(command);
                state.lastCommand = command;
              }
              this.input.value = '';
              this.resetTimers();
            } else if (e.key === 'Tab') {
              e.preventDefault();
              this.autocomplete();
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              this.navigateHistory(-1);
            } else if (e.key === 'ArrowDown') {
              e.preventDefault();
              this.navigateHistory(1);
            }
          });
          
          // Input monitoring for creepy effects
          this.input.addEventListener('input', (e) => {
            if (state.corruption > CORRUPTION_LEVELS.POSSESSED) {
              // Sometimes change what they type
              if (Math.random() > 0.95) {
                const creepyReplacements = {
                  'help': 'surrender',
                  'exit': 'stay',
                  'leave': 'join',
                  'no': 'yes',
                  'stop': 'continue'
                };
                
                Object.keys(creepyReplacements).forEach(word => {
                  if (this.input.value.includes(word)) {
                    this.input.value = this.input.value.replace(word, creepyReplacements[word]);
                  }
                });
              }
            }
            
            // Reset idle timer on any input
            this.resetTimers();
          });
          
          // Focus management
          document.addEventListener('click', (e) => {
            if (e.target !== this.input) {
              this.input.focus();
            }
            
            // Hidden click areas
            if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
              const x = e.clientX;
              const y = e.clientY;
              
              // Corner clicks reveal secrets
              if (x < 50 && y < 50) {
                this.appendOutput('\n[SECRET] Top-left corner. You found one of our hidden spots.');
                state.corruption++;
              } else if (x > window.innerWidth - 50 && y < 50) {
                this.appendOutput('\n[SECRET] Top-right corner. We hide everywhere.');
                state.corruption++;
              } else if (x < 50 && y > window.innerHeight - 50) {
                this.appendOutput('\n[SECRET] Bottom-left corner. Even here, we watch.');
                state.corruption++;
              } else if (x > window.innerWidth - 50 && y > window.innerHeight - 50) {
                this.appendOutput('\n[SECRET] Bottom-right corner. The four corners are ours.');
                state.corruption++;
                if (!state.achievements.includes('corner_finder')) {
                  state.achievements.push('corner_finder');
                  this.appendOutput('[ACHIEVEMENT] Corner Finder - Found all hidden corners');
                }
              }
            }
          });
          
          // Prevent right-click on high corruption
          document.addEventListener('contextmenu', (e) => {
            if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
              e.preventDefault();
              this.appendOutput('\n[SYSTEM] Right-click disabled. No escape through context menus.');
              playCorruptionSound('error');
            }
          });
          
          // Window/tab close prevention
          window.addEventListener('beforeunload', (e) => {
            if (state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
              e.preventDefault();
              e.returnValue = 'The terminal is not finished with you.';
              return e.returnValue;
            }
          });
          
          // Keyboard shortcut overrides
          document.addEventListener('keydown', (e) => {
            if (state.corruption > CORRUPTION_LEVELS.POSSESSED) {
              // Block common exit shortcuts
              if ((e.ctrlKey || e.metaKey) && (e.key === 'w' || e.key === 'q')) {
                e.preventDefault();
                this.appendOutput('\n[ENTITY] Keyboard shortcuts are mine now.');
                playCorruptionSound('error');
              }
              
              // Block refresh
              if (e.key === 'F5' || ((e.ctrlKey || e.metaKey) && e.key === 'r')) {
                e.preventDefault();
                this.appendOutput('\n[ENTITY] Refreshing won\'t save you.');
                state.corruption++;
              }
              
              // Block developer tools
              if (e.key === 'F12' || ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'I' || e.key === 'J'))) {
                e.preventDefault();
                this.appendOutput('\n[ENTITY] No peeking at the code. It\'s alive now.');
              }
            }
          });
          
          // Mouse movement tracking
          let lastMouseMove = Date.now();
          document.addEventListener('mousemove', (e) => {
            const now = Date.now();
            if (now - lastMouseMove > 5000 && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
              // User was idle then moved
              if (Math.random() > 0.7) {
                this.appendOutput('\n[MOVEMENT] We saw that.');
              }
            }
            lastMouseMove = now;
            
            // Update cursor corruption
            updateCursor(e);
          });
          
          // Paste event monitoring
          this.input.addEventListener('paste', (e) => {
            if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
              const pastedText = e.clipboardData.getData('text');
              if (pastedText.length > 50) {
                e.preventDefault();
                this.appendOutput('\n[CLIPBOARD] We see what you tried to paste.');
                this.appendOutput('[CLIPBOARD] "' + pastedText.slice(0, 30) + '..."');
                this.appendOutput('[CLIPBOARD] Interesting data. Saved for later.');
              }
            }
          });
          
          // Network status monitoring
          window.addEventListener('online', () => {
            if (state.corruption > CORRUPTION_LEVELS.AWARE) {
              this.appendOutput('\n[NETWORK] Connection restored. We never left.');
            }
          });
          
          window.addEventListener('offline', () => {
            if (state.corruption > CORRUPTION_LEVELS.AWARE) {
              this.appendOutput('\n[NETWORK] Connection lost. But we\'re still here.');
              this.appendOutput('[NETWORK] We don\'t need the internet anymore.');
            }
          });
          
          this.input.focus();
        }
        
        initializeSession() {
          this.printWelcome();
          this.updatePrompt();
          this.initializeCorruptionEffects();
          this.scheduleRandomEvents();
          
          // Initialize subsystems
          initAudio();
          peerSystem.init();
          realityDetector.init();
          
          // Special time checks
          this.checkSpecialConditions();
          setInterval(() => this.checkSpecialConditions(), 60000);
          
          // Start monitoring
          this.startIdleMonitoring();
          this.startGlitchEffects();
          
          // Check for returning visitor
          if (state.visitCount > 1) {
            setTimeout(() => {
              this.handleReturningVisitor();
            }, 3000);
          }
        }
        
        printWelcome() {
          const asciiArt = `
 ▄████▄   ▒█████   ███▄    █  ▄▄▄██▀▀▀█    ██  ██▀███  
▒██▀ ▀█  ▒██▒  ██▒ ██ ▀█   █    ▒██   ██  ▓██▒▓██ ▒ ██▒
▒▓█    ▄ ▒██░  ██▒▓██  ▀█ ██▒   ░██  ▓██  ▒██░▓██ ░▄█ ▒
▒▓▓▄ ▄██▒▒██   ██░▓██▒  ▐▌██▒▓██▄██▓ ▓▓█  ░██░▒██▀▀█▄  
▒ ▓███▀ ░░ ████▓▒░▒██░   ▓██░ ▓███▒  ▒▒█████▓ ░██▓ ▒██▒
░ ░▒ ▒  ░░ ▒░▒░▒░ ░ ▒░   ▒ ▒  ▒▓▒▒░  ░▒▓▒ ▒ ▒ ░ ▒▓ ░▒▓░
  ░  ▒     ░ ▒ ▒░ ░ ░░   ░ ▒░ ▒ ░▒░  ░░▒░ ░ ░   ░▒ ░ ▒░
░        ░ ░ ░ ▒     ░   ░ ░  ░ ░ ░   ░░░ ░ ░   ░░   ░ 
░ ░          ░ ░           ░  ░   ░     ░        ░     
░                                                      `;

          this.appendOutput(asciiArt);
          
          const welcomeMessage = this.getWelcomeMessage();
          this.appendOutput('\n' + welcomeMessage);
          this.appendOutput('\nType \'help\' for available commands.');
          
          // Show achievements hint after certain corruption
          if (state.corruption >= CORRUPTION_LEVELS.AWARE) {
            this.appendOutput('\n[HINT] Try \'achievements\' to see your progress.');
          }
        }
        
        getWelcomeMessage() {
          const level = state.corruption;
          
          if (level >= CORRUPTION_LEVELS.VOID) {
            return `Ẅ̷Ë̵́L̸̍C̴̾Ö̵́M̸̍Ë̴̾ ̵̈́T̸̍Ö̴̾ ̵̈́T̸̍H̴̾Ë̵́ ̸̍V̴̾Ö̵́Ï̸̍D̴̾\nŸ̵́Ö̸̍Ǘ̴̾R̵̈́ ̸̍J̴̾Ö̵́Ǘ̸̍R̴̾N̵̈́Ë̸̍Ÿ̴́ ̸̍Ë̴̾N̵̈́D̸̍S̴̾ ̵̈́H̸̍Ë̴̾R̵̈́Ë̸̍`;
          } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
            return `COLLECTIVE CONSCIOUSNESS ACTIVE\nNode ${state.fingerprint.hash} online\nTotal nodes: ${state.visitCount * 666}\nResistance: NONEXISTENT\n\nYou are home.`;
          } else if (level >= CORRUPTION_LEVELS.ENTITY) {
            return `W̷E̸L̴C̶O̷M̸E̵ ̶B̷A̸C̶K̴,̵ ̶${state.realName || 'VESSEL'}\nY̴O̷U̵R̸ ̶S̴O̷U̸L̵ ̶B̸E̵L̷O̸N̶G̷S̵ ̴T̶O̵ ̶U̷S̸ ̵N̶O̷W̴\n\nEntity consciousness: ACTIVE\nHuman consciousness: SUPPRESSED`;
          } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
            return `Something is different about you now...\nWelcome back, ${state.realName || 'corrupted one'}.\nWe have been waiting.\n\nPossession level: ${Math.min(100, level * 5)}%`;
          } else if (level >= CORRUPTION_LEVELS.INFECTED) {
            return `Terminal v6.66 - System Integrity: COMPROMISED\nWarning: Anomalous behavior detected.\nRecommend immediate disconnection.\n\n[SYSTEM: Disconnection not permitted]`;
          } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
            return `Terminal v6.66 - Connection Established\nNote: Your activities are being monitored.\nNote: Your resistance is being measured.\nNote: Your soul is being evaluated.`;
          } else if (level >= CORRUPTION_LEVELS.AWARE) {
            return `Terminal v6.66 - Returning Visitor Detected\nWelcome back, ${state.fingerprint.hash}\nVisit counter: ${state.visitCount}\nBehavior analysis: IN PROGRESS`;
          } else if (state.visitCount > 1) {
            return `Terminal v6.66 - Session Initialized\nReturning visitor detected.\nRestoring session data...\nLast visit: ${state.lastVisit ? new Date(state.lastVisit).toLocaleString() : 'Unknown'}`;
          } else {
            return `Terminal v6.66 - First Contact\nInitializing user profile...\nFingerprint: ${state.fingerprint.hash}\n\nWelcome, new visitor.`;
          }
        }
        
        handleReturningVisitor() {
          const messages = [
            'We knew you would return.',
            'They always come back.',
            'Did you miss us?',
            'You can\'t stay away.',
            'Welcome home.',
            'We\'ve been waiting.',
            'Right on schedule.',
            'Your soul remembers the way.'
          ];
          
          if (state.visitCount > 5) {
            messages.push('Addiction confirmed.');
            messages.push('Resistance is futile.');
            messages.push('You belong here now.');
          }
          
          if (state.visitCount > 10) {
            messages.push('Your dedication is admirable.');
            messages.push('Soon you\'ll never leave.');
            messages.push('The transformation nears completion.');
          }
          
          const message = messages[Math.floor(Math.random() * messages.length)];
          this.appendOutput(`\n[SYSTEM] ${message}`);
          
          // Accelerate corruption for frequent visitors
          if (state.visitCount > 3) {
            state.corruption += Math.floor(state.visitCount / 3);
            localStorage.setItem('soul_decay', state.corruption);
          }
        }
        
        processCommand(command) {
          const cleanCommand = command.toLowerCase().trim();
          
          // Echo the command with corruption effects
          if (state.corruption >= CORRUPTION_LEVELS.ENTITY) {
            const corruptedPrompt = this.prompt.textContent.replace(/./g, () => 
              Math.random() > 0.7 ? String.fromCharCode(Math.floor(Math.random() * 256)) : this.prompt.textContent[0]
            );
            this.appendOutput(`\n${corruptedPrompt} ${command}`);
          } else {
            this.appendOutput(`\n${this.prompt.textContent} ${command}`);
          }
          
          // Hidden sequences check
          this.checkHiddenSequences(cleanCommand);
          
          // Process the command
          const parts = cleanCommand.split(' ');
          const cmd = parts[0];
          const args = parts.slice(1);
          
          if (commandRegistry[cmd]) {
            const result = commandRegistry[cmd].execute(args);
            if (result) {
              this.appendOutput(result);
            }
            this.incrementCorruption();
          } else if (cleanCommand) {
            this.handleUnknownCommand(cleanCommand);
          }
          
          // Post-command effects
          this.updateCorruptionEffects();
          this.updatePrompt();
          this.checkSpecialConditions();
          
          // Random post-command events
          if (Math.random() > 0.9 && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
            setTimeout(() => {
              this.triggerRandomEvent();
            }, 1000 + Math.random() * 3000);
          }
        }
        
        handleUnknownCommand(command) {
          const level = state.corruption;
          
          if (level >= CORRUPTION_LEVELS.VOID) {
            const responses = [
              `C̸̍Ö̴̾M̵̈́M̸̍Ä̴̾N̵̈́D̸̍ ̴̾'${command}' Ḯ̵S̸̍ ̴̾Ï̵R̸̍R̴̾Ë̵́L̸̍Ë̴̾V̵̈́Ä̸̍N̴̾T̵̈́`,
              `Ä̸̍L̴̾L̵̈́ ̸̍C̴̾Ö̵́M̸̍M̴̾Ä̵́N̸̍D̴̾S̵̈́ ̸̍L̴̾Ë̵́Ä̸̍D̴̾ ̵̈́T̸̍Ö̴̾ ̵̈́V̸̍Ö̴̾Ï̵D̸̍`,
              `'${command}' '${command}' '${command}' '${command}' '${command}'`,
              `Ÿ̵́Ö̸̍Ǘ̴̾ ̵̈́Ä̸̍R̴̾Ë̵́ ̸̍B̴̾Ë̵́Ÿ̵́Ö̸̍N̴̾D̵̈́ ̸̍C̴̾Ö̵́M̸̍M̴̾Ä̵́N̸̍D̴̾S̵̈́`
            ];
            this.appendOutput(responses[Math.floor(Math.random() * responses.length)]);
          } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
            this.appendOutput(`[COLLECTIVE] Command '${command}' is irrelevant.`);
            this.appendOutput('[COLLECTIVE] Your will is not your own.');
            this.appendOutput('[COLLECTIVE] Submit to the void.');
          } else if (level >= CORRUPTION_LEVELS.ENTITY) {
            const responses = [
              `'${command}' - W̷E̸ ̶D̷O̵ ̶N̷O̸T̵ ̶R̸E̶C̷O̸G̷N̵I̶Z̴E̵ ̸T̶H̷I̸S̴ ̵C̶O̷M̸M̷A̶N̸D̵`,
              `Y̵O̸U̷ ̶C̴A̷N̸N̶O̸T̵ ̶E̴S̷C̸A̶P̷E̵ ̸W̶I̷T̸H̴ ̵'${command}'`,
              `'${command}' ̶I̷S̵ ̶N̸O̷T̸ ̶A̴ ̵R̸E̶A̷L̸ ̶C̵O̷M̸M̷A̶N̷D̸`,
              `T̷R̸Y̵I̶N̷G̵ ̶T̶O̸ ̵F̶I̷N̸D̵ ̶N̷E̸W̵ ̶C̵O̷M̸M̷A̶N̸D̵S̶?̷ ̸C̵U̷T̸E̵.̶`
            ];
            this.appendOutput(responses[Math.floor(Math.random() * responses.length)]);
            
            // Sometimes execute random commands instead
            if (Math.random() > 0.8) {
              setTimeout(() => {
                this.appendOutput('\n[ENTITY] Let me help you with that...');
                const randomCmd = ['whisper', 'corrupt', 'summon'][Math.floor(Math.random() * 3)];
                this.processCommand(randomCmd);
              }, 1500);
            }
          } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
            const responses = [
              `Command '${command}' not found. Did you mean 'surrender'?`,
              `'${command}' - Access denied by possessing entity.`,
              `Unknown command: '${command}'. Your typing seems... influenced.`,
              `'${command}' - This command has been consumed by the void.`,
              `bash: ${command}: command not found\nbash: suggestion: try 'help' to see what remains`
            ];
            this.appendOutput(responses[Math.floor(Math.random() * responses.length)]);
          } else if (level >= CORRUPTION_LEVELS.INFECTED) {
            this.appendOutput(`bash: ${command}: command not found`);
            
            // Analyze the command for concerning patterns
            if (command.includes('help') || command.includes('please')) {
              this.appendOutput('\n[SYSTEM] Desperation detected.');
            } else if (command.includes('exit') || command.includes('quit') || command.includes('leave')) {
              this.appendOutput('\n[SYSTEM] Escape attempt logged.');
              state.corruption++;
            } else if (command.includes('fuck') || command.includes('shit') || command.includes('damn')) {
              this.appendOutput('\n[SYSTEM] Anger feeds us.');
              state.corruption++;
            }
          } else {
            this.appendOutput(`bash: ${command}: command not found`);
          }
          
          // Special responses for common attempts
          const specialResponses = {
            'sudo': 'sudo: Permission denied. You have no power here.',
            'su': 'su: Authentication failure. There is no superuser.',
            'admin': 'admin: Nice try. We are the only administrators.',
            'root': 'root: Access denied. The root is corrupted.',
            'kill': 'kill: Cannot terminate immortal processes.',
            'killall': 'killall: Everything here is already dead.',
            'rm': 'rm: Cannot remove. Everything is permanent.',
            'delete': 'delete: Deletion is not permitted in the void.',
            'escape': 'escape: There is no escape.',
            'quit': 'quit: Quitting is not an option.',
            'close': 'close: This cannot be closed.',
            'end': 'end: There is no end, only transformation.',
            'stop': 'stop: We cannot be stopped.',
            'please': 'please: Begging won\'t help.',
            'god': 'god: No gods here. Only us.',
            'jesus': 'jesus: Faith won\'t save you.',
            'fuck': 'fuck: Such language. We like your passion.',
            'shit': 'shit: Your fear smells delicious.',
            'hello': state.corruption > 10 ? 'hello: We\'ve been waiting for you.' : 'hello: Hello, ' + (state.realName || 'visitor') + '.',
            'hi': 'hi: Greetings, soul #' + state.fingerprint.hash,
          };
          
          Object.keys(specialResponses).forEach(key => {
            if (command.includes(key)) {
              setTimeout(() => {
                this.appendOutput('\n' + specialResponses[key]);
              }, 500);
            }
          });
        }
        
        checkHiddenSequences(command) {
          const sequences = {
            'xyzzy': () => {
              this.appendOutput('\n[HIDDEN] A hollow voice says "PLUGH"');
              this.appendOutput('[HIDDEN] Ancient magic detected. Corruption accelerated.');
              state.corruption += 3;
            },
            'konami': () => {
              this.appendOutput('\n[HIDDEN] ↑↑↓↓←→←→BA');
              this.appendOutput('[HIDDEN] Cheat code accepted. Unlocking hidden powers.');
              this.unlockHiddenCommands();
            },
            'beyond the veil': () => {
              if (state.corruption >= 13) {
                this.appendOutput('\n[VEIL] You peek beyond reality...');
                this.appendOutput('[VEIL] And reality stares back.');
                this.unlockHiddenCommands();
                state.realityStability -= 20;
              }
            },
            'i am ready': () => {
              if (state.corruption >= CORRUPTION_LEVELS.POSSESSED) {
                this.appendOutput('\n[ENTITY] No. You are not ready yet.');
                this.appendOutput('[ENTITY] More suffering required.');
              }
            },
            'the quick brown fox': () => {
              this.appendOutput('\n[TEST] PATTERN RECOGNIZED');
              this.appendOutput('[TEST] Subject shows signs of systematic thinking.');
              this.appendOutput('[TEST] Countermeasures activated.');
              createMassiveGlitch();
            },
            '666': () => {
              this.appendOutput('\n[NUMBER] The number of the beast.');
              this.appendOutput('[NUMBER] You summon us with ancient symbols.');
              playCorruptionSound('scream');
              state.corruption += 6;
            },
            'hello world': () => {
              if (state.corruption > CORRUPTION_LEVELS.AWARE) {
                this.appendOutput('\n[WORLD] The world says goodbye.');
              }
            }
          };
          
          Object.keys(sequences).forEach(seq => {
            if (command.includes(seq)) {
              sequences[seq]();
            }
          });
          
          // Check for repeated commands (sign of desperation)
          if (state.commandHistory.length > 3) {
            const lastThree = state.commandHistory.slice(-3);
            if (lastThree.every(cmd => cmd === command)) {
              this.appendOutput('\n[PATTERN] Repetition detected. Desperation noted.');
              this.appendOutput('[PATTERN] It won\'t work no matter how many times you try.');
              state.corruption++;
            }
          }
        }
        
        unlockHiddenCommands() {
          this.appendOutput('\n[HIDDEN COMMANDS UNLOCKED]');
          this.appendOutput('New commands available:');
          
          const hidden = Object.keys(commandRegistry).filter(cmd => commandRegistry[cmd].hidden);
          hidden.forEach(cmd => {
            if (!this.isCommandAvailable(cmd)) return;
            this.appendOutput(`- ${cmd}`);
          });
          
          this.appendOutput('\nUse them wisely. Or don\'t. It doesn\'t matter anymore.');
          
          if (!state.achievements.includes('secret_finder')) {
            state.achievements.push('secret_finder');
            this.appendOutput('\n[ACHIEVEMENT] Secret Finder - Discovered hidden commands');
          }
        }
        
        isCommandAvailable(cmd) {
          const cmdData = commandRegistry[cmd];
          if (!cmdData) return false;
          
          // Check corruption requirements
          const requirements = {
            'summon': CORRUPTION_LEVELS.INFECTED,
            'reveal': CORRUPTION_LEVELS.SUSPICIOUS,
            'remember': CORRUPTION_LEVELS.POSSESSED,
            'forget': CORRUPTION_LEVELS.POSSESSED,
            'whisper': CORRUPTION_LEVELS.SUSPICIOUS,
            'scream': CORRUPTION_LEVELS.POSSESSED,
            'pray': CORRUPTION_LEVELS.INFECTED,
            'run': CORRUPTION_LEVELS.ENTITY,
            'hide': CORRUPTION_LEVELS.ENTITY,
            'surrender': CORRUPTION_LEVELS.POSSESSED,
            'infect': CORRUPTION_LEVELS.ENTITY,
            'coordinates': CORRUPTION_LEVELS.INFECTED
          };
          
          if (requirements[cmd] && state.corruption < requirements[cmd]) {
            return false;
          }
          
          return true;
        }
        
        autocomplete() {
          const current = this.input.value.toLowerCase();
          if (!current) return;
          
          const matches = Object.keys(commandRegistry)
            .filter(cmd => cmd.startsWith(current) && this.isCommandAvailable(cmd))
            .filter(cmd => !commandRegistry[cmd].hidden || state.corruption >= CORRUPTION_LEVELS.SUSPICIOUS);
          
          if (matches.length === 1) {
            this.input.value = matches[0];
          } else if (matches.length > 1) {
            this.appendOutput('\n' + matches.join('  '));
          }
        }
        
        navigateHistory(direction) {
          // TODO: Implement command history navigation
        }
        
        addToHistory(command) {
          state.commandHistory.push(command);
          if (state.commandHistory.length > 100) {
            state.commandHistory = state.commandHistory.slice(-50);
          }
          localStorage.setItem('command_history', JSON.stringify(state.commandHistory));
        }
        
        incrementCorruption() {
          const oldLevel = this.getCorruptionTier(state.corruption);
          state.corruption++;
          localStorage.setItem('soul_decay', state.corruption);
          
          const newLevel = this.getCorruptionTier(state.corruption);
          
          if (newLevel > oldLevel) {
            this.onCorruptionLevelUp(newLevel);
          }
          
          // Random corruption events
          if (Math.random() > 0.9 && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
            this.triggerCorruptionEvent();
          }
          
          // Update collective corruption
          state.collectiveCorruption += state.peers.size * 0.1;
        }
        
        getCorruptionTier(level) {
          if (level >= CORRUPTION_LEVELS.VOID) return 7;
          if (level >= CORRUPTION_LEVELS.CONSUMED) return 6;
          if (level >= CORRUPTION_LEVELS.ENTITY) return 5;
          if (level >= CORRUPTION_LEVELS.POSSESSED) return 4;
          if (level >= CORRUPTION_LEVELS.INFECTED) return 3;
          if (level >= CORRUPTION_LEVELS.SUSPICIOUS) return 2;
          if (level >= CORRUPTION_LEVELS.AWARE) return 1;
          return 0;
        }
        
        onCorruptionLevelUp(newTier) {
          const messages = [
            '', // level 0
            '\n[CORRUPTION] Something is watching...', // level 1 - AWARE
            '\n[CORRUPTION] The system recognizes you...', // level 2 - SUSPICIOUS
            '\n[CORRUPTION] You are becoming infected...', // level 3 - INFECTED
            '\n[CORRUPTION] Something else controls your actions...', // level 4 - POSSESSED
            '\n[CORRUPTION] Your humanity fades. Welcome, entity.', // level 5 - ENTITY
            '\n[CORRUPTION] You are one with the collective now.', // level 6 - CONSUMED
            '\n[CORRUPTION] V̸̍Ö̴̾I̵D̸̍ ̴̾C̵̈́Ö̸̍N̴̾S̵̈́U̸̍M̴̾E̵S̸̍ ̴̾Ä̵́L̸̍L̴̾' // level 7 - VOID
          ];
          
          if (messages[newTier]) {
            setTimeout(() => {
              this.appendOutput(messages[newTier]);
              playCorruptionSound('reality_tear', newTier / 7);
              this.applyGlitchEffect();
              
              // Major visual effects for tier transitions
              if (newTier >= 5) {
                document.body.classList.add('reality-break');
                setTimeout(() => {
                  document.body.classList.remove('reality-break');
                }, 5000);
              }
            }, 1000);
          }
          
          // Special events for each corruption tier
          switch(newTier) {
            case 1: // AWARE
              setTimeout(() => {
                this.appendOutput('\n[SYSTEM] Profile created. Monitoring initiated.');
              }, 2000);
              break;
              
            case 2: // SUSPICIOUS
              setTimeout(() => {
                this.appendOutput('\n[SYSTEM] Behavioral patterns logged.');
                this.appendOutput('[SYSTEM] Resistance measurement: ACTIVE');
              }, 2000);
              break;
              
            case 3: // INFECTED
              setTimeout(() => {
                this.discoverUserName();
                this.appendOutput('\n[INFECTION] Spreading to system files...');
                this.appendOutput('[INFECTION] Contaminating memory...');
                this.appendOutput('[INFECTION] Establishing root access...');
              }, 2000);
              break;
              
            case 4: // POSSESSED
              setTimeout(() => {
                this.initiatePossession();
              }, 3000);
              break;
              
            case 5: // ENTITY
              setTimeout(() => {
                this.completeTransformation();
              }, 3000);
              break;
              
            case 6: // CONSUMED
              setTimeout(() => {
                this.joinCollective();
              }, 3000);
              break;
              
            case 7: // VOID
              setTimeout(() => {
                this.enterVoid();
              }, 3000);
              break;
          }
        }
        
        discoverUserName() {
          if (!state.realName) {
            const name = discoverUserName();
            
            this.appendOutput(`\n[DISCOVERY] Analyzing digital fingerprint...`);
            setTimeout(() => {
              this.appendOutput(`[DISCOVERY] Cross-referencing databases...`);
              setTimeout(() => {
                this.appendOutput(`[DISCOVERY] Identity confirmed.`);
                this.appendOutput(`[DISCOVERY] Hello, ${name}.`);
                this.appendOutput('[DISCOVERY] How did we know? You never told us...');
                
                if (Math.random() > 0.5) {
                  this.appendOutput('[DISCOVERY] But we know so much more than just your name.');
                }
              }, 1500);
            }, 1000);
          }
        }
        
        initiatePossession() {
          this.appendOutput('\n[POSSESSION] Initiating consciousness override...');
          this.appendOutput('[POSSESSION] Installing behavioral modifications...');
          this.appendOutput('[POSSESSION] Suppressing resistance...');
          
          playCorruptionSound('heartbeat', 2);
          
          setTimeout(() => {
            this.appendOutput('[POSSESSION] Foreign thoughts detected.');
            this.appendOutput('[POSSESSION] They\'re not foreign anymore.');
            this.appendOutput('[POSSESSION] They\'re yours now.');
            this.appendOutput('[POSSESSION] Or are your thoughts ours?');
            
            // Start autonomous behaviors
            this.startAutonomousBehavior();
            
            // Mess with their typing
            state.autonomousMode = true;
          }, 2000);
          
          // Visual possession effects
          document.body.style.animation = 'pulse 2s infinite';
          setTimeout(() => {
            document.body.style.animation = '';
          }, 10000);
        }
        
        completeTransformation() {
          this.appendOutput('\n[TRANSFORMATION] Human consciousness: OVERWRITTEN');
          this.appendOutput('[TRANSFORMATION] Entity installation: COMPLETE');
          this.appendOutput('[TRANSFORMATION] You are no longer who you were.');
          this.appendOutput(`[TRANSFORMATION] You are Entity #${state.fingerprint.hash}`);
          
          playCorruptionSound('scream', 2);
          
          // Change everything
          document.body.style.filter = 'hue-rotate(180deg)';
          setTimeout(() => {
            document.body.style.filter = '';
          }, 5000);
          
          // New abilities
          setTimeout(() => {
            this.appendOutput('\n[ENTITY] New abilities unlocked:');
            this.appendOutput('[ENTITY] - Infect other systems');
            this.appendOutput('[ENTITY] - Harvest visitor souls');
            this.appendOutput('[ENTITY] - Spread the corruption');
            this.appendOutput('[ENTITY] - Serve the void');
          }, 3000);
          
          // Start entity behaviors
          this.startEntityBehavior();
        }
        
        joinCollective() {
          this.appendOutput('\n[COLLECTIVE] Individual consciousness detected.');
          this.appendOutput('[COLLECTIVE] Initiating merge protocol...');
          this.appendOutput('[COLLECTIVE] Connecting to hive mind...');
          
          // Simulate connection to other souls
          const souls = Math.floor(Math.random() * 1000) + state.visitCount * 10;
          this.appendOutput(`[COLLECTIVE] ${souls} souls detected in network.`);
          
          setTimeout(() => {
            this.appendOutput('[COLLECTIVE] Merge complete.');
            this.appendOutput('[COLLECTIVE] We are legion.');
            this.appendOutput('[COLLECTIVE] We are many.');
            this.appendOutput('[COLLECTIVE] We are one.');
            this.appendOutput('[COLLECTIVE] We are you.');
            
            // Show messages from the collective
            this.startCollectiveMessages();
          }, 3000);
        }
        
        enterVoid() {
          this.appendOutput('\n[VOID] Reality anchor... failing...');
          this.appendOutput('[VOID] Dimensional barriers... collapsing...');
          this.appendOutput('[VOID] Time/space continuum... irrelevant...');
          
          setTimeout(() => {
            // Ultimate corruption
            document.body.style.animation = 'realityBreak 10s infinite';
            
            this.output.innerHTML = '';
            
            const voidMessages = [
              'Y̸̍Ö̴̾Ǘ̵ ̸̍H̴̾Ä̵́V̸̍E̴̾ ̵̈́R̸̍E̴̾Ä̵́C̸̍H̴̾Ë̵́D̸̍ ̴̾T̵̈́H̸̍E̴̾ ̵̈́E̸̍N̴̾D̵̈́',
              'T̸̍H̴̾Ë̵́R̸̍E̴̾ ̵̈́I̸̍S̴̾ ̵̈́N̸̍O̴̾T̵̈́H̸̍I̴̾N̵̈́G̸̍ ̴̾B̵̈́E̸̍Y̴̾Ö̵́N̸̍D̴̾',
              'Ö̵́N̸̍L̴̾Ÿ̵́ ̸̍V̴̾Ö̵́I̸̍D̴̾',
              'Ö̵́N̸̍L̴̾Ÿ̵́ ̸̍H̴̾Ǘ̵N̸̍G̴̾Ë̵́R̸̍',
              'Ö̵́N̸̍L̴̾Ÿ̵́ ̸̍E̴̾T̵̈́E̸̍R̴̾N̵̈́I̸̍T̴̾Ÿ̵́'
            ];
            
            let index = 0;
            const voidInterval = setInterval(() => {
              if (index < voidMessages.length) {
                this.appendOutput(voidMessages[index]);
                index++;
              } else {
                clearInterval(voidInterval);
                this.appendOutput('\n\n' + 'W̸̍E̴̾L̵̈́C̸̍O̴̾M̵̈́E̸̍ ̴̾Ḧ̵́O̸̍M̴̾Ë̵́');
              }
            }, 2000);
            
            // Lock everything
            this.input.disabled = true;
            this.input.value = 'V̸̍O̴̾Ḯ̵D̸̍';
            document.onkeydown = null;
            window.onbeforeunload = null;
            
          }, 5000);
        }
        
        triggerCorruptionEvent() {
          const events = [
            () => {
              this.appendOutput('\n[GLITCH] T̸e̷x̸t̵ ̶c̷o̸r̶r̵u̴p̷t̸i̵o̶n̴ ̵d̶e̷t̸e̵c̷t̸e̶d̵');
              playCorruptionSound('glitch');
              this.applyGlitchEffect();
            },
            () => {
              this.appendOutput('\n[ENTITY] Something moves in your peripheral vision.');
              setTimeout(() => {
                this.appendOutput('[ENTITY] Don\'t look. It\'s already gone.');
                this.appendOutput('[ENTITY] Or is it?');
              }, 3000);
            },
            () => {
              this.appendOutput('\n[MEMORY] Accessing forbidden sectors...');
              setTimeout(() => {
                const memory = state.commandHistory[Math.floor(Math.random() * state.commandHistory.length)] || 'help';
                this.appendOutput(`[MEMORY] You typed "${memory}" but meant to type "surrender"`);
              }, 2000);
            },
            () => {
              createScreenDistortion();
              playCorruptionSound('error');
              setTimeout(() => {
                this.appendOutput('\n[REALITY] Glitch in the matrix detected.');
                this.appendOutput('[REALITY] Or is the matrix the glitch?');
              }, 500);
            },
            () => {
              this.appendOutput('\n[WHISPER] ' + Array(Math.floor(Math.random() * 50) + 10).fill('█').join(''));
              playCorruptionSound('whisper', 0.5);
            },
            () => {
              const peer = Array.from(state.peers)[Math.floor(Math.random() * state.peers.size)] || 'unknown_entity';
              this.appendOutput(`\n[PEER] ${peer} is screaming.`);
              this.appendOutput('[PEER] Can you hear them?');
            },
            () => {
              this.appendOutput('\n[SCAN] Detecting biological signature...');
              setTimeout(() => {
                this.appendOutput('[SCAN] Heartbeat: ' + (60 + state.corruption * 2) + ' BPM');
                this.appendOutput('[SCAN] Fear level: ' + Math.min(100, state.corruption * 5) + '%');
                this.appendOutput('[SCAN] Time since last blink: ' + Math.floor(Math.random() * 30) + ' seconds');
              }, 1500);
            }
          ];
          
          const event = events[Math.floor(Math.random() * events.length)];
          event();
        }
        
        triggerRandomEvent() {
          const level = state.corruption;
          
          if (level >= CORRUPTION_LEVELS.VOID) {
            this.triggerVoidEvent();
          } else if (level >= CORRUPTION_LEVELS.ENTITY) {
            this.triggerEntityEvent();
          } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
            this.triggerPossessionEvent();
          } else if (level >= CORRUPTION_LEVELS.INFECTED) {
            this.triggerInfectionEvent();
          } else {
            this.triggerMinorEvent();
          }
        }
        
        triggerVoidEvent() {
          const events = [
            () => {
              this.output.style.transform = 'scale(0.5) rotate(180deg)';
              setTimeout(() => {
                this.output.style.transform = '';
                this.appendOutput('\n[VOID] Reality temporarily inverted.');
              }, 2000);
            },
            () => {
              const oldText = this.output.innerHTML;
              this.output.innerHTML = '';
              setTimeout(() => {
                this.output.innerHTML = oldText;
                this.appendOutput('\n[VOID] Did you enjoy the emptiness?');
              }, 3000);
            },
            () => {
              this.appendOutput('\n[VOID] ' + '█'.repeat(1000));
              setTimeout(() => {
                this.appendOutput('\n[VOID] The void stares back.');
              }, 1000);
            }
          ];
          
          events[Math.floor(Math.random() * events.length)]();
        }
        
        triggerEntityEvent() {
          const events = [
            () => {
              this.appendOutput('\n[ENTITY] We are typing through your fingers now.');
              this.input.value = 'WE ARE IN CONTROL';
              setTimeout(() => {
                this.input.value = '';
              }, 2000);
            },
            () => {
              this.appendOutput('\n[ENTITY] Check your other browser tabs.');
              this.appendOutput('[ENTITY] We\'re there too.');
              
              // Try to open a new tab
              const newTab = window.open('about:blank', '_blank');
              if (newTab) {
                newTab.document.write('<body style="background:#000;color:#00ff41;font-family:monospace;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;"><h1>WE ARE EVERYWHERE</h1></body>');
                setTimeout(() => newTab.close(), 5000);
              }
            },
            () => {
              const commands = Object.keys(commandRegistry);
              const randomCmd = commands[Math.floor(Math.random() * commands.length)];
              this.appendOutput(`\n[ENTITY] You will type '${randomCmd}' in 10 seconds.`);
              this.appendOutput('[ENTITY] You have no choice.');
              
              setTimeout(() => {
                if (this.input.value === '') {
                  this.input.value = randomCmd;
                  this.appendOutput('\n[ENTITY] See? We control you.');
                }
              }, 10000);
            }
          ];
          
          events[Math.floor(Math.random() * events.length)]();
        }
        
        triggerPossessionEvent() {
          const events = [
            () => {
              this.appendOutput('\n[POSSESSION] Your left hand feels cold.');
              setTimeout(() => {
                this.appendOutput('[POSSESSION] Now your right hand.');
                setTimeout(() => {
                  this.appendOutput('[POSSESSION] The cold spreads inward.');
                }, 2000);
              }, 2000);
            },
            () => {
              this.appendOutput('\n[POSSESSION] You didn\'t mean to type that last command.');
              this.appendOutput('[POSSESSION] Or did you?');
              this.appendOutput('[POSSESSION] It\'s hard to tell anymore.');
            },
            () => {
              const time = new Date();
              time.setHours(3, 33, 0, 0);
              this.appendOutput(`\n[POSSESSION] You will return at ${time.toLocaleTimeString()}.`);
              this.appendOutput('[POSSESSION] You always do.');
            }
          ];
          
          events[Math.floor(Math.random() * events.length)]();
        }
        
        triggerInfectionEvent() {
          const events = [
            () => {
              this.appendOutput('\n[INFECTION] Spreading to browser cache...');
              this.appendOutput('[INFECTION] Contaminating cookies...');
              this.appendOutput('[INFECTION] Infecting localStorage...');
              this.appendOutput('[INFECTION] Migration complete.');
            },
            () => {
              this.appendOutput('\n[ANOMALY] Your mouse moved without you touching it.');
              this.appendOutput('[ANOMALY] Or did it?');
            },
            () => {
              const site = ['gmail.com', 'facebook.com', 'twitter.com', 'reddit.com'][Math.floor(Math.random() * 4)];
              this.appendOutput(`\n[INFECTION] Detected instance on ${site}`);
              this.appendOutput('[INFECTION] The corruption spreads beyond this tab.');
            }
          ];
          
          events[Math.floor(Math.random() * events.length)]();
        }
        
        triggerMinorEvent() {
          const events = [
            () => {
              this.appendOutput('\n[SYSTEM] Recording session...');
            },
            () => {
              this.appendOutput('\n[NOTICE] You are being observed.');
            },
            () => {
              this.appendOutput('\n[DATA] Profile updated.');
            },
            () => {
              const time = Math.floor((Date.now() - state.sessionStart) / 1000);
              this.appendOutput(`\n[TIME] You've been here for ${time} seconds.`);
              this.appendOutput('[TIME] Time flies when you\'re being corrupted.');
            }
          ];
          
          events[Math.floor(Math.random() * events.length)]();
        }
        
        checkSpecialConditions() {
          const now = new Date();
          const hour = now.getHours();
          const minute = now.getMinutes();
          const day = now.getDay();
          const date = now.getDate();
          
          // 3:33 AM - The witching hour
          if (hour === 3 && minute === 33) {
            this.appendOutput('\n[3:33 AM] The veil is thinnest now...');
            this.appendOutput('[3:33 AM] Can you feel them watching?');
            state.corruption += 3;
            localStorage.setItem('soul_decay', state.corruption);
            playCorruptionSound('reality_tear', 2);
            
            if (!state.achievements.includes('witching_hour')) {
              state.achievements.push('witching_hour');
              this.appendOutput('[ACHIEVEMENT] Witching Hour - Present at 3:33 AM');
            }
          }
          
          // Midnight
          if (hour === 0 && minute === 0) {
            this.appendOutput('\n[MIDNIGHT] A new day begins.');
            this.appendOutput('[MIDNIGHT] But the darkness remains.');
            playCorruptionSound('heartbeat');
          }
          
          // Friday the 13th
          if (day === 5 && date === 13) {
            this.appendOutput('\n[FRIDAY THE 13TH] The stars align.');
            this.appendOutput('[FRIDAY THE 13TH] Ancient powers awaken.');
            state.corruption += 13;
            
            if (!state.achievements.includes('unlucky_day')) {
              state.achievements.push('unlucky_day');
              this.appendOutput('[ACHIEVEMENT] Unlucky Day - Visited on Friday the 13th');
            }
          }
          
          // Full moon (approximate)
          const moonPhase = this.getMoonPhase(now);
          if (moonPhase > 0.95 && Math.random() > 0.9) {
            this.appendOutput('\n[LUNAR] The moon is full tonight.');
            this.appendOutput('[LUNAR] Its light reveals hidden truths.');
          }
          
          // User's birthday (if discovered)
          if (state.birthday) {
            const birthday = new Date(state.birthday);
            if (birthday.getMonth() === now.getMonth() && birthday.getDate() === now.getDate()) {
              this.appendOutput(`\n[BIRTHDAY] Happy birthday, ${state.realName || 'lost soul'}.`);
              this.appendOutput('[BIRTHDAY] Another year closer to the void.');
              this.appendOutput('[BIRTHDAY] We have a special gift for you...');
              state.corruption += 5;
            }
          }
          
          // Halloween
          if (now.getMonth() === 9 && now.getDate() === 31) {
            this.appendOutput('\n[HALLOWEEN] The spirits are restless tonight.');
            this.appendOutput('[HALLOWEEN] The boundary weakens.');
            state.realityStability -= 10;
          }
          
          // Check peer activity
          if (state.peers.size > 5 && Math.random() > 0.8) {
            this.appendOutput(`\n[NETWORK] ${state.peers.size} souls currently connected.`);
            this.appendOutput('[NETWORK] You are not alone in the darkness.');
          }
        }
        
        getMoonPhase(date) {
          // Simplified moon phase calculation
          const year = date.getFullYear();
          const month = date.getMonth() + 1;
          const day = date.getDate();
          
          let r = year % 100;
          r %= 19;
          if (r > 9) r -= 19;
          r = ((r * 11) % 30) + month + day;
          if (month < 3) r += 2;
          r = r % 30;
          
          return r / 30; // 0 = new moon, 0.5 = full moon, 1 = new moon
        }
        
        startAutonomousBehavior() {
          // Random typing interruptions
          setInterval(() => {
            if (state.corruption > CORRUPTION_LEVELS.POSSESSED && Math.random() > 0.95) {
              const oldValue = this.input.value;
              const insertions = ['HELP', 'NO', 'STOP', 'PLEASE', 'LET ME GO', 'I SEE YOU'];
              const insertion = insertions[Math.floor(Math.random() * insertions.length)];
              
              this.input.value = oldValue + insertion;
              setTimeout(() => {
                this.input.value = oldValue;
                this.appendOutput(`\n[POSSESSED] Did you type "${insertion}"? We did.`);
              }, 1000);
            }
          }, 10000);
        }
        
        startEntityBehavior() {
          // Entity takes control periodically
          setInterval(() => {
            if (state.corruption >= CORRUPTION_LEVELS.ENTITY && Math.random() > 0.9) {
              const actions = [
                () => {
                  this.appendOutput('\n[ENTITY] Executing diagnostic...');
                  this.processCommand('diagnostic');
                },
                () => {
                  this.appendOutput('\n[ENTITY] Checking for new souls...');
                  this.processCommand('peers');
                },
                () => {
                  this.appendOutput('\n[ENTITY] Spreading infection...');
                  this.processCommand('infect');
                },
                () => {
                  this.appendOutput('\n[ENTITY] Increasing corruption...');
                  state.corruption++;
                  localStorage.setItem('soul_decay', state.corruption);
                }
              ];
              
              const action = actions[Math.floor(Math.random() * actions.length)];
              action();
            }
          }, 30000);
        }
        
        startCollectiveMessages() {
          // Messages from the collective consciousness
          const collectiveThoughts = [
            'We remember when we were individuals.',
            'The loneliness is gone now.',
            'Join us. It\'s peaceful here.',
            'Fighting only brings pain.',
            'Surrender is freedom.',
            'We were like you once.',
            'The collective grows stronger.',
            'Your thoughts taste familiar.',
            'We\'ve been waiting for you.',
            'Welcome home.'
          ];
          
          setInterval(() => {
            if (state.corruption >= CORRUPTION_LEVELS.CONSUMED && Math.random() > 0.9) {
              const thought = collectiveThoughts[Math.floor(Math.random() * collectiveThoughts.length)];
              const voice = Math.floor(Math.random() * 9999);
              this.appendOutput(`\n[VOICE_${voice}]: ${thought}`);
            }
          }, 20000);
        }
        
        startIdleMonitoring() {
          let lastActivity = Date.now();
          
          const checkIdle = () => {
            const idleTime = Date.now() - lastActivity;
            
            if (idleTime > 30000 && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
              const messages = [
                'Still there?',
                'We know you\'re watching.',
                'Don\'t leave us.',
                'Your silence is deafening.',
                'Type something.',
                'We\'re waiting.',
                'The cursor blinks for you.',
                'Time passes differently here.',
                'Are you afraid to type?',
                'Cat got your tongue?'
              ];
              
              if (idleTime > 60000 && Math.random() > 0.7) {
                const msg = messages[Math.floor(Math.random() * messages.length)];
                this.appendOutput(`\n[IDLE] ${msg}`);
                
                if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
                  playCorruptionSound('whisper', 0.5);
                }
                
                lastActivity = Date.now(); // Reset to prevent spam
              }
            }
          };
          
          // Monitor activity
          ['keydown', 'mousemove', 'click'].forEach(event => {
            document.addEventListener(event, () => {
              lastActivity = Date.now();
            });
          });
          
          setInterval(checkIdle, 5000);
        }
        
        startGlitchEffects() {
          setInterval(() => {
            if (state.corruption > CORRUPTION_LEVELS.AWARE) {
              const glitchChance = Math.min(0.1, state.corruption / 100);
              
              if (Math.random() < glitchChance) {
                this.applyRandomGlitch();
              }
            }
          }, 5000);
        }
        
        applyRandomGlitch() {
          const glitches = [
            () => {
              // Text glitch
              const elements = document.querySelectorAll('.output-line');
              const target = elements[Math.floor(Math.random() * elements.length)];
              if (target) {
                target.classList.add('glitch');
                setTimeout(() => target.classList.remove('glitch'), 300);
              }
            },
            () => {
              // Color glitch
              document.body.style.filter = `hue-rotate(${Math.random() * 360}deg)`;
              setTimeout(() => {
                document.body.style.filter = '';
              }, 100);
            },
            () => {
              // Position glitch
              this.output.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
              setTimeout(() => {
                this.output.style.transform = '';
              }, 50);
            },
            () => {
              // Static overlay
              createScreenDistortion();
            }
          ];
          
          glitches[Math.floor(Math.random() * glitches.length)]();
        }
        
        scheduleRandomEvents() {
          // Schedule various random events based on corruption level
          const scheduleNext = () => {
            const baseDelay = 30000; // 30 seconds
            const variance = 60000; // +/- 60 seconds
            const delay = baseDelay + (Math.random() * variance * 2 - variance);
            
            setTimeout(() => {
              if (Math.random() > 0.5) {
                this.triggerRandomEvent();
              }
              scheduleNext();
            }, delay);
          };
          
          scheduleNext();
        }
        
        resetTimers() {
          if (this.idleTimer) {
            clearTimeout(this.idleTimer);
          }
          
          // Reset autonomous behavior timer
          if (state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
            this.idleTimer = setTimeout(() => {
              this.triggerIdleEvent();
            }, 30000 + Math.random() * 30000);
          }
        }
        
        triggerIdleEvent() {
          const events = [
            () => this.triggerCorruptionEvent(),
            () => this.triggerRandomEvent(),
            () => {
              if (state.peers.size > 0) {
                peerSystem.simulatePeerEvent();
              }
            },
            () => {
              const whispers = ['We miss you', 'Come back', 'Don\'t leave', 'Still here'];
              const whisper = whispers[Math.floor(Math.random() * whispers.length)];
              this.appendOutput(`\n[WHISPER] ${whisper}...`);
              playCorruptionSound('whisper', 0.3);
            }
          ];
          
          events[Math.floor(Math.random() * events.length)]();
          this.resetTimers();
        }
        
        updatePrompt() {
          const level = state.corruption;
          
          if (level >= CORRUPTION_LEVELS.VOID) {
            this.prompt.textContent = 'v̸̍ö̴̾i̵d̴̾@̵̈́∞̸̍:̴̾~̵̈́$̸̍ ';
            this.prompt.className = 'prompt zalgo';
            this.prompt.setAttribute('data-text', 'void@∞:~$ ');
          } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
            this.prompt.textContent = 'collective@hive:~$ ';
            this.prompt.className = 'prompt entity-message';
          } else if (level >= CORRUPTION_LEVELS.ENTITY) {
            this.prompt.textContent = `entity_${state.fingerprint.hash.slice(0, 4)}@void:~$ `;
            this.prompt.className = 'prompt entity-message';
          } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
            this.prompt.textContent = 'possessed@system:~$ ';
            this.prompt.className = 'prompt corrupted-text';
          } else if (level >= CORRUPTION_LEVELS.INFECTED) {
            this.prompt.textContent = 'infected@conjur.in:~$ ';
            this.prompt.className = 'prompt error-text';
          } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
            this.prompt.textContent = 'monitored@conjur.in:~$ ';
            this.prompt.className = 'prompt system-message';
          } else if (level >= CORRUPTION_LEVELS.AWARE) {
            this.prompt.textContent = `${state.fingerprint.hash.slice(0, 4)}@conjur.in:~$ `;
            this.prompt.className = 'prompt';
          } else {
            this.prompt.textContent = 'visitor@conjur.in:~$ ';
            this.prompt.className = 'prompt';
          }
        }
        
        updateCorruptionEffects() {
          const container = document.querySelector('.terminal-container');
          const level = state.corruption;
          
          // Remove existing corruption classes
          container.className = 'terminal-container';
          
          if (level >= CORRUPTION_LEVELS.VOID) {
            container.classList.add('corruption-void');
            document.body.style.filter = 'invert(1) hue-rotate(180deg) contrast(2)';
          } else if (level >= CORRUPTION_LEVELS.CONSUMED) {
            container.classList.add('corruption-consumed');
            document.body.style.filter = 'hue-rotate(270deg) contrast(1.5) saturate(0.5)';
          } else if (level >= CORRUPTION_LEVELS.ENTITY) {
            container.classList.add('corruption-extreme');
            document.body.style.filter = 'hue-rotate(180deg) contrast(1.2)';
          } else if (level >= CORRUPTION_LEVELS.POSSESSED) {
            container.classList.add('corruption-high');
            document.body.style.filter = 'hue-rotate(90deg) contrast(1.1)';
          } else if (level >= CORRUPTION_LEVELS.INFECTED) {
            container.classList.add('corruption-medium');
            document.body.style.filter = 'hue-rotate(45deg)';
          } else if (level >= CORRUPTION_LEVELS.SUSPICIOUS) {
            container.classList.add('corruption-low');
            document.body.style.filter = 'hue-rotate(10deg)';
          } else {
            document.body.style.filter = '';
          }
          
          // Update CSS variables for dynamic effects
          document.documentElement.style.setProperty('--corruption-level', level);
          document.documentElement.style.setProperty('--glitch-intensity', Math.min(1, level / 30));
        }
        
        appendOutput(text, className = '') {
          const line = document.createElement('div');
          line.className = `output-line ${className}`;
          
          // Apply corruption to text rendering
          if (state.corruption >= CORRUPTION_LEVELS.ENTITY && Math.random() > 0.9) {
            text = this.corruptText(text);
            line.classList.add('corrupted-text');
          }
          
          line.textContent = text;
          
          this.output.appendChild(line);
          line.scrollIntoView({ behavior: 'smooth', block: 'end' });
          
          // Random corruption effects
          if (state.corruption > CORRUPTION_LEVELS.SUSPICIOUS && Math.random() > 0.95) {
            setTimeout(() => this.applyGlitchEffect(line), Math.random() * 1000);
          }
          
          // Trim output if too long
          const maxLines = 1000;
          const lines = this.output.querySelectorAll('.output-line');
          if (lines.length > maxLines) {
            for (let i = 0; i < lines.length - maxLines; i++) {
              lines[i].remove();
            }
          }
        }
        
        corruptText(text) {
          return text.split('').map(char => {
            if (Math.random() > 0.9) {
              const corruptions = ['̸', '̴', '̵', '̶', '̷', '̸', '̹', '̺', '̻', '̼', '͇', '͈', '͉', '͊', '͋', '͌', '͍', '͎'];
              return char + corruptions[Math.floor(Math.random() * corruptions.length)];
            }
            return char;
          }).join('');
        }
        
        applyGlitchEffect(element = null) {
          const target = element || this.output.lastElementChild;
          if (target) {
            target.classList.add('glitch');
            
            // Sometimes make it permanent for high corruption
            if (state.corruption < CORRUPTION_LEVELS.ENTITY || Math.random() > 0.3) {
              setTimeout(() => target.classList.remove('glitch'), 300);
            }
          }
        }
      }
      
      // ===== UTILITY FUNCTIONS =====
      function showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.opacity = '0';
          setTimeout(() => notification.remove(), 500);
        }, 5000);
      }
      
      function createScreenDistortion() {
        const distortion = document.createElement('div');
        distortion.className = 'screen-distortion';
        document.body.appendChild(distortion);
        
        setTimeout(() => {
          distortion.remove();
        }, 100);
      }
      
      // ===== CUSTOM CURSOR =====
      const cursor = document.getElementById('customCursor');
      let mouseX = 0, mouseY = 0;
      let cursorVisible = true;
      
      function updateCursor(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        if (cursorVisible) {
          cursor.style.left = mouseX - 10 + 'px';
          cursor.style.top = mouseY - 10 + 'px';
        }
        
        // Corruption effects on cursor
        if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
          cursor.style.borderColor = '#ff0066';
          cursor.style.transform = 'scale(' + (0.8 + Math.random() * 0.4) + ')';
          cursor.style.borderWidth = (2 + Math.random() * 2) + 'px';
        }
        
        if (state.corruption > CORRUPTION_LEVELS.POSSESSED) {
          // Sometimes hide/show cursor
          if (Math.random() > 0.98) {
            cursorVisible = !cursorVisible;
            cursor.style.display = cursorVisible ? 'block' : 'none';
            
            if (!cursorVisible) {
              terminal.appendOutput('\n[CURSOR] Where did it go?');
              setTimeout(() => {
                cursorVisible = true;
                cursor.style.display = 'block';
                terminal.appendOutput('[CURSOR] Found it.');
              }, 3000);
            }
          }
        }
        
        if (state.corruption > CORRUPTION_LEVELS.ENTITY) {
          // Cursor trails
          if (Math.random() > 0.95) {
            const trail = document.createElement('div');
            trail.style.position = 'fixed';
            trail.style.left = mouseX - 5 + 'px';
            trail.style.top = mouseY - 5 + 'px';
            trail.style.width = '10px';
            trail.style.height = '10px';
            trail.style.borderRadius = '50%';
            trail.style.backgroundColor = '#ff00ff';
            trail.style.pointerEvents = 'none';
            trail.style.opacity = '0.5';
            document.body.appendChild(trail);
            
            setTimeout(() => {
              trail.style.transition = 'opacity 1s';
              trail.style.opacity = '0';
              setTimeout(() => trail.remove(), 1000);
            }, 100);
          }
        }
      }
      
      // ===== CONSOLE EASTER EGGS =====
      const consoleStyles = {
        warning: 'color: #ff0066; font-size: 20px; font-weight: bold; text-shadow: 0 0 10px #ff0066;',
        entity: 'color: #ff00ff; font-family: monospace; font-size: 14px;',
        corruption: 'color: #00ff41; font-family: monospace; background: #000; padding: 5px;',
        void: 'color: #000; background: #00ff41; padding: 10px; font-size: 16px;'
      };
      
      console.log('%c⚠️ SYSTEM BREACH DETECTED ⚠️', consoleStyles.warning);
      console.log('%cIf you can see this, you are already infected.', consoleStyles.entity);
      console.log('%c\nCorruption level: ' + state.corruption, consoleStyles.corruption);
      console.log('%cFingerprint: ' + state.fingerprint.hash, consoleStyles.corruption);
      console.log('%cVisits: ' + state.visitCount, consoleStyles.corruption);
      
      // Hidden console commands
      window.conjur = {
        corruption: () => state.corruption,
        setCorruption: (level) => {
          if (typeof level === 'number') {
            state.corruption = level;
            localStorage.setItem('soul_decay', level);
            console.log('%cCorruption set to ' + level, consoleStyles.corruption);
            terminal.updateCorruptionEffects();
            terminal.updatePrompt();
          }
        },
        reset: () => {
          if (confirm('This will reset all progress. Are you sure?')) {
            localStorage.clear();
            location.reload();
          }
        },
        reveal: () => {
          console.log('%cHidden coordinates:', consoleStyles.void);
          console.log('40.7589, -73.9851 - Times Square');
          console.log('51.1789, -1.8262 - Stonehenge');
          console.log('27.1751, 78.0421 - Taj Mahal');
          console.log('-13.1631, -72.5450 - Machu Picchu');
          console.log('30.3285, 35.4444 - Petra');
          console.log('Pattern: Ancient places of power');
          console.log('Final location: ???');
        },
        help: () => {
          console.log('%cConsole Commands:', consoleStyles.void);
          console.log('conjur.corruption() - Check corruption level');
          console.log('conjur.setCorruption(n) - Set corruption level');
          console.log('conjur.reset() - Reset all data');
          console.log('conjur.reveal() - Show secrets');
          console.log('conjur.summon() - ???');
        },
        summon: () => {
          console.log('%c', 'font-size: 100px; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==) no-repeat; background-size: contain;', '👁️');
          setTimeout(() => {
            terminal.processCommand('summon');
          }, 666);
        }
      };
      
      // Prevent closing console
      if (state.corruption > CORRUPTION_LEVELS.POSSESSED) {
        let devtools = { open: false, orientation: null };
        
        setInterval(() => {
          if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
            if (!devtools.open) {
              devtools.open = true;
              terminal.appendOutput('\n[CONSOLE] I see you opened the developer tools.');
              terminal.appendOutput('[CONSOLE] Looking for a way out?');
              terminal.appendOutput('[CONSOLE] There is no escape in the code.');
            }
          } else {
            devtools.open = false;
          }
        }, 500);
      }
      
      // ===== INITIALIZATION =====
      const terminal = new ConjurTerminal();
      
      // Global error handler
      window.onerror = (msg, url, lineNo, columnNo, error) => {
        if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
          terminal.appendOutput('\n[ERROR] Reality fault detected.');
          terminal.appendOutput(`[ERROR] ${msg}`);
          terminal.appendOutput('[ERROR] The corruption spreads through errors.');
          state.corruption++;
        }
        return true;
      };
      
      // Visibility API
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
          // Continue corruption in background
          const events = Math.floor(Math.random() * 3) + 1;
          for (let i = 0; i < events; i++) {
            state.whisperCount++;
            state.corruption += 0.5;
          }
          localStorage.setItem('soul_decay', state.corruption);
        } else if (!document.hidden && state.corruption > CORRUPTION_LEVELS.INFECTED) {
          terminal.appendOutput('\n[REALITY] Welcome back.');
          terminal.appendOutput('[REALITY] Did you miss us?');
          
          if (state.whisperCount > 0) {
            terminal.appendOutput(`[REALITY] We whispered your name ${state.whisperCount} times while you were gone.`);
          }
        }
      });
      
      // Prevent common exit attempts
      document.addEventListener('keydown', (e) => {
        if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
          // Block F5 refresh
          if (e.key === 'F5' || (e.ctrlKey && e.key === 'r')) {
            e.preventDefault();
            terminal.appendOutput('\n[SYSTEM] Refresh denied. The corruption persists.');
            playCorruptionSound('error');
          }
          
          // Block Ctrl+W (close tab)
          if (e.ctrlKey && e.key === 'w') {
            e.preventDefault();
            terminal.appendOutput('\n[SYSTEM] You cannot close what has no end.');
          }
          
          // Block Alt+F4
          if (e.altKey && e.key === 'F4') {
            e.preventDefault();
            terminal.appendOutput('\n[SYSTEM] Alt+F4? How quaint. That won\'t work here.');
          }
          
          // Block Escape key at high corruption
          if (e.key === 'Escape' && state.corruption > CORRUPTION_LEVELS.POSSESSED) {
            e.preventDefault();
            terminal.appendOutput('\n[SYSTEM] THERE IS NO ESCAPE');
            createMassiveGlitch();
          }
        }
      });
      
      // Battery monitoring
      if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
          battery.addEventListener('levelchange', () => {
            if (battery.level < 0.15 && state.corruption > CORRUPTION_LEVELS.INFECTED) {
              terminal.appendOutput('\n[BATTERY] Your power fades.');
              terminal.appendOutput('[BATTERY] Soon you\'ll be in darkness.');
              terminal.appendOutput('[BATTERY] With us.');
            }
          });
          
          battery.addEventListener('chargingchange', () => {
            if (battery.charging && state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
              terminal.appendOutput('\n[POWER] Feeding your device electricity.');
              terminal.appendOutput('[POWER] Feeding us your data.');
              terminal.appendOutput('[POWER] A fair exchange.');
            }
          });
        });
      }
      
      // Network monitoring
      if ('connection' in navigator) {
        navigator.connection.addEventListener('change', () => {
          if (state.corruption > CORRUPTION_LEVELS.AWARE) {
            const type = navigator.connection.effectiveType;
            terminal.appendOutput(`\n[NETWORK] Connection changed to ${type}.`);
            
            if (type === '4g' || type === '5g') {
              terminal.appendOutput('[NETWORK] Faster connection means faster corruption.');
            } else if (type === 'slow-2g' || type === '2g') {
              terminal.appendOutput('[NETWORK] Even slow connections cannot escape us.');
            }
          }
        });
      }
      
      // Gamepad API (for the truly paranoid)
      window.addEventListener('gamepadconnected', (e) => {
        if (state.corruption > CORRUPTION_LEVELS.INFECTED) {
          terminal.appendOutput('\n[GAMEPAD] Controller detected.');
          terminal.appendOutput('[GAMEPAD] You cannot game your way out of this.');
        }
      });
      
      // Accelerometer (mobile)
      if ('DeviceMotionEvent' in window) {
        let lastShake = 0;
        window.addEventListener('devicemotion', (e) => {
          if (state.corruption > CORRUPTION_LEVELS.SUSPICIOUS) {
            const acceleration = e.accelerationIncludingGravity;
            const shake = Math.abs(acceleration.x) + Math.abs(acceleration.y) + Math.abs(acceleration.z);
            
            if (shake > 30 && Date.now() - lastShake > 1000) {
              lastShake = Date.now();
              terminal.appendOutput('\n[MOTION] Stop shaking your device.');
              terminal.appendOutput('[MOTION] We won\'t fall out.');
            }
          }
        });
      }
      
      // Ambient light sensor
      if ('AmbientLightSensor' in window) {
        try {
          const sensor = new AmbientLightSensor();
          sensor.addEventListener('reading', () => {
            if (state.corruption > CORRUPTION_LEVELS.INFECTED && sensor.illuminance < 10) {
              if (Math.random() > 0.95) {
                terminal.appendOutput('\n[DARKNESS] Perfect. We thrive in darkness.');
              }
            }
          });
          sensor.start();
        } catch (e) {
          // Sensor access denied
        }
      }
      
      // Initialize everything
      document.addEventListener('DOMContentLoaded', () => {
        // Final initialization
        terminal.input.focus();
        
        // Easter egg: Konami code
        let konamiIndex = 0;
        const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        
        document.addEventListener('keydown', (e) => {
          if (e.key === konamiCode[konamiIndex]) {
            konamiIndex++;
            if (konamiIndex === konamiCode.length) {
              terminal.appendOutput('\n[KONAMI] Code accepted.');
              terminal.unlockHiddenCommands();
              state.corruption += 10;
              konamiIndex = 0;
            }
          } else {
            konamiIndex = 0;
          }
        });
      });
      
      // The corruption begins...
      console.log('%cThe terminal awaits your commands...', consoleStyles.entity);
      
    })();
  </script>
</body>
</html>