<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>conjur.in - your personal entity awaits</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        } /* <-- Add this closing brace */

        #summon-btn:active {
            transform: scale(0.98);
        }
        
        body {
            background: #0a0a0a;
            color: #ccc;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 600px;
            padding: 20px;
            text-align: center;
        }
        
        #loading {
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
        }
        
        #entity-reveal {
            display: none;
            animation: fadeIn 3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #entity-canvas {
            width: 300px;
            height: 300px;
            margin: 30px auto;
            border: 1px solid #333;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.1);
            animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.1); }
            50% { box-shadow: 0 0 50px rgba(255, 0, 0, 0.3); }
        }
        
        .entity-speaking {
            animation: pulse 2s ease-in-out infinite !important;
            box-shadow: 0 0 60px rgba(255, 0, 0, 0.5) !important;
        }
        
        .speaking .entity-name {
            animation: shimmer 3s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0%, 100% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.3); }
            50% { text-shadow: 0 0 20px rgba(255, 100, 100, 0.8); }
        }
        
        .entity-name {
            font-family: 'Cinzel', serif;
            font-size: 36px;
            color: #fff;
            margin: 20px 0;
            letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .entity-title {
            font-size: 16px;
            color: #888;
            font-style: italic;
            margin-bottom: 30px;
        }
        
        .entity-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border: 1px solid #222;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 24px;
            color: #fff;
            margin-top: 5px;
        }
        
        .binding-instructions {
            background: rgba(255, 0, 0, 0.05);
            border: 1px solid #330000;
            padding: 20px;
            margin: 30px 0;
            text-align: left;
            font-size: 14px;
            line-height: 1.8;
        }
        
        .binding-title {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            color: #fff;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .binding-step {
            margin: 10px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .binding-step::before {
            content: "◈";
            position: absolute;
            left: 0;
            color: #660000;
        }
        
        .abilities {
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #222;
        }
        
        .abilities-title {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .ability {
            margin: 10px 0;
            font-size: 14px;
            color: #aaa;
        }
        
        .share-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 1px solid #333;
        }
        
        .share-url {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            margin: 10px 0;
            word-break: break-all;
            font-size: 12px;
            color: #666;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .share-url:hover {
            background: #1a1a1a;
            color: #999;
        }
        
        .warning {
            margin-top: 30px;
            font-size: 11px;
            color: #444;
            font-style: italic;
        }
        
        .rune {
            display: inline-block;
            font-size: 20px;
            margin: 0 5px;
            animation: flicker 3s infinite;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        #summon-btn {
            background: none;
            border: 1px solid #660000;
            color: #cc0000;
            padding: 15px 40px;
            font-family: 'Cinzel', serif;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 40px;
            letter-spacing: 2px;
            text-transform: lowercase;
        }
        
        .viewing-other {
            border-color: #003366 !important;
            box-shadow: 0 0 30px rgba(0, 100, 200, 0.2) !important;
        }
        
        .other-entity-notice {
            background: rgba(0, 50, 100, 0.1);
            border: 1px solid #003366;
            padding: 15px;
            margin: 20px 0;
            font-size: 14px;
            color: #88aacc;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="loading">
            <p>reading your essence...</p>
            <p style="margin-top: 10px;">
                <span class="rune">☿</span>
                <span class="rune">☽</span>
                <span class="rune">☾</span>
                <span class="rune">☿</span>
            </p>
        </div>
        
        <div id="entity-reveal">
            <canvas id="entity-canvas" width="300" height="300"></canvas>
            
            <h1 class="entity-name" id="entity-name"></h1>
            <p class="entity-title" id="entity-title"></p>
            
            <div class="entity-stats">
                <div class="stat">
                    <div class="stat-label">Potency</div>
                    <div class="stat-value" id="stat-potency"></div>
                </div>
                <div class="stat">
                    <div class="stat-label">Volatility</div>
                    <div class="stat-value" id="stat-volatility"></div>
                </div>
                <div class="stat">
                    <div class="stat-label">Resonance</div>
                    <div class="stat-value" id="stat-resonance"></div>
                </div>
            </div>
            
            <div class="abilities">
                <div class="abilities-title">Manifestations</div>
                <div id="abilities-list"></div>
            </div>
            
            <div class="binding-instructions">
                <div class="binding-title">Binding Protocol</div>
                <div id="binding-steps"></div>
            </div>
            
            <div class="share-section">
                <p style="color: #666; margin-bottom: 10px;">Share your entity's summoning seal:</p>
                <div class="share-url" id="share-url" onclick="copyToClipboard()"></div>
                <p style="font-size: 12px; color: #444; margin-top: 5px;">click to copy</p>
            </div>
            
            <p class="warning">
                Warning: Each browser soul may only bind one entity. 
                Clear your spiritual cache to summon anew.
            </p>
            
            <button id="summon-btn" onclick="playEntitySound()" title="Each entity speaks with its own voice">hear its voice</button>
        </div>
    </div>

    <script>
        // Global audio context
        let audioContext;
        let currentEntity;
        let analyser;
        let animationId;
        
        // Entity sound generator
        function playEntitySound() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const btn = document.getElementById('summon-btn');
            
            if (btn.textContent === 'hear its voice') {
                // Get entity stats
                const resonance = parseInt(document.getElementById('stat-resonance').textContent);
                const potency = parseInt(document.getElementById('stat-potency').textContent);
                const volatility = parseInt(document.getElementById('stat-volatility').textContent);
                
                // Create the entity's voice
                createEntityVoice(resonance, potency, volatility);
                btn.textContent = 'silence';
                
                // Add visual feedback
                document.getElementById('entity-canvas').classList.add('entity-speaking');
                document.getElementById('entity-reveal').classList.add('speaking');
                
                // Start audio visualization
                if (analyser) {
                    visualizeAudio();
                }
            } else {
                // Stop all sounds
                if (window.activeOscillators) {
                    window.activeOscillators.forEach(osc => {
                        try { osc.stop(); } catch(e) {}
                    });
                    window.activeOscillators = [];
                }
                if (audioContext.state === 'running') {
                    audioContext.suspend();
                }
                btn.textContent = 'hear its voice';
                
                // Remove visual feedback
                document.getElementById('entity-canvas').classList.remove('entity-speaking');
                document.getElementById('entity-reveal').classList.remove('speaking');
                
                // Stop visualization
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                    // Redraw static sigil
                    drawEntity(currentEntity);
                }
            }
        }
        
        function createEntityVoice(resonance, potency, volatility) {
            // Resume context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Base frequency from resonance (map to audible range)
            const baseFreq = (resonance / 1000) * 400 + 80; // 80-480 Hz range
            
            // Volume from potency (map to 0-0.15 range for safety)
            const volume = (potency / 1000) * 0.15;
            
            // Create master gain
            const masterGain = audioContext.createGain();
            masterGain.gain.value = volume;
            
            // Create analyser for visualization
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            masterGain.connect(analyser);
            analyser.connect(audioContext.destination);
            
            // Create multiple oscillators for rich texture
            for (let i = 0; i < 3; i++) {
                const osc = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                // Slightly detune oscillators for richness
                osc.frequency.value = baseFreq * (1 + i * 0.01);
                osc.type = i === 0 ? 'sine' : (i === 1 ? 'triangle' : 'sawtooth');
                
                // Individual oscillator volume
                oscGain.gain.value = i === 0 ? 0.4 : 0.2;
                
                // Filter setup
                filter.type = 'lowpass';
                filter.frequency.value = baseFreq * 4;
                filter.Q.value = 5 + (volatility / 10);
                
                // Connect chain
                osc.connect(filter);
                filter.connect(oscGain);
                
                // Add distortion based on volatility
                if (volatility > 30) {
                    const distortion = audioContext.createWaveShaper();
                    distortion.curve = makeDistortionCurve(volatility);
                    distortion.oversample = '4x';
                    oscGain.connect(distortion);
                    distortion.connect(masterGain);
                } else {
                    oscGain.connect(masterGain);
                }
                
                // Start oscillator
                osc.start();
                
                // Modulation based on volatility
                if (volatility > 50) {
                    const lfo = audioContext.createOscillator();
                    const lfoGain = audioContext.createGain();
                    
                    lfo.frequency.value = volatility / 20; // 2.5-5 Hz
                    lfoGain.gain.value = volatility * 0.5; // Subtle frequency modulation
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    lfo.start();
                    
                    // Store LFO for cleanup
                    window.activeOscillators.push(lfo);
                }
                
                // Store for cleanup
                if (!window.activeOscillators) window.activeOscillators = [];
                window.activeOscillators.push(osc);
            }
            
            // Add reverb for ethereal quality
            createReverb(masterGain, volatility);
            
            // Fade in
            masterGain.gain.setValueAtTime(0, audioContext.currentTime);
            masterGain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 1);
        }
        
        function makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = Math.tanh(x * (amount / 20));
            }
            
            return curve;
        }
        
        function createReverb(source, volatility) {
            const convolver = audioContext.createConvolver();
            const length = audioContext.sampleRate * 2;
            const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2 + volatility / 50);
                }
            }
            
            convolver.buffer = impulse;
            
            const reverbGain = audioContext.createGain();
            reverbGain.gain.value = 0.1 + (volatility / 200);
            
            const reverbSend = audioContext.createGain();
            reverbSend.gain.value = 0.3;
            
            source.connect(reverbSend);
            reverbSend.connect(convolver);
            convolver.connect(reverbGain);
            reverbGain.connect(analyser);
        }
        
        // Audio visualization
        function visualizeAudio() {
            if (!analyser || audioContext.state !== 'running') return;
            
            const canvas = document.getElementById('entity-canvas');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function draw() {
                animationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                
                // Clear canvas with fade effect
                ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Redraw base sigil with audio-reactive modifications
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Get average frequency amplitude
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                const scale = 1 + (average / 255) * 0.3;
                
                // Draw pulsing outer circle
                ctx.strokeStyle = `rgba(204, 0, 0, ${0.3 + average / 500})`;
                ctx.lineWidth = 2 + average / 50;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 120 * scale, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw frequency bars as rays
                ctx.strokeStyle = `rgba(102, 0, 0, 0.8)`;
                for (let i = 0; i < bufferLength; i += 4) {
                    const angle = (i / bufferLength) * Math.PI * 2;
                    const barHeight = (dataArray[i] / 255) * 50;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        centerX + Math.cos(angle) * 80,
                        centerY + Math.sin(angle) * 80
                    );
                    ctx.lineTo(
                        centerX + Math.cos(angle) * (80 + barHeight),
                        centerY + Math.sin(angle) * (80 + barHeight)
                    );
                    ctx.stroke();
                }
                
                // Redraw entity core with glow
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 40 * scale);
                gradient.addColorStop(0, `rgba(204, 0, 0, ${0.5 + average / 300})`);
                gradient.addColorStop(1, 'rgba(204, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 40 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
            
            draw();
        }
        
        // Stop sounds when navigating away
        window.addEventListener('beforeunload', () => {
            if (audioContext && audioContext.state === 'running') {
                audioContext.close();
            }
        });
        
        // Generate browser fingerprint
        async function generateFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('fingerprint', 2, 2);
            const canvasData = canvas.toDataURL();
            
            const fingerprint = {
                canvas: canvasData,
                screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                platform: navigator.platform,
                cores: navigator.hardwareConcurrency || 0,
                memory: navigator.deviceMemory || 0,
                vendor: navigator.vendor,
                userAgent: navigator.userAgent
            };
            
            // Create hash from fingerprint
            const str = JSON.stringify(fingerprint);
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            
            return Math.abs(hash);
        }
        
        // Generate entity based on fingerprint or provided seed
        async function generateEntity(providedSeed = null) {
            const fingerprint = providedSeed || await generateFingerprint();
            const seed = fingerprint;
            
            // Seeded random number generator
            let s = seed;
            const random = () => {
                s = (s * 16807) % 2147483647;
                return (s - 1) / 2147483646;
            };
            
            // Generate name
            const prefixes = ['Zar', 'Mor', 'Vel', 'Kaz', 'Nyx', 'Bel', 'Raz', 'Mal', 'Vor', 'Xal'];
            const middles = ['\'', 'ath', 'gor', 'thos', 'iel', 'oth', 'esh', 'ul', 'ar', 'ez'];
            const suffixes = ['oth', 'ian', 'iel', 'esh', 'ul', 'ar', 'on', 'im', 'el', 'ux'];
            
            const name = prefixes[Math.floor(random() * prefixes.length)] +
                        middles[Math.floor(random() * middles.length)] +
                        suffixes[Math.floor(random() * suffixes.length)];
            
            // Generate title
            const titles = [
                'The Whisperer in Static',
                'Keeper of Forgotten Names',
                'The Threshold Guardian',
                'Weaver of Digital Shadows',
                'The Memory Eater',
                'Herald of Corrupted Data',
                'The Pattern Breaker',
                'Collector of Lost Packets',
                'The Glitch Prophet',
                'Architect of Broken Links'
            ];
            
            const title = titles[Math.floor(random() * titles.length)];
            
            // Generate stats
            const potency = Math.floor(random() * 900) + 100;
            const volatility = Math.floor(random() * 100);
            const resonance = Math.floor(random() * 1000);
            
            // Generate abilities
            const allAbilities = [
                'Induces temporal loops in electronic devices',
                'Feeds on abandoned browser tabs',
                'Manifests through dead pixels',
                'Corrupts autosaved documents',
                'Whispers through cooling fans',
                'Appears in reflections on black screens',
                'Causes phantom notifications',
                'Rewrites cached memories',
                'Haunts unread emails',
                'Dwells in recursive functions',
                'Breeds in memory leaks',
                'Speaks through error messages'
            ];
            
            const abilities = [];
            const numAbilities = Math.floor(random() * 3) + 2;
            for (let i = 0; i < numAbilities; i++) {
                const index = Math.floor(random() * allAbilities.length);
                abilities.push(allAbilities[index]);
            }
            
            // Generate binding instructions
            const actions = [
                'Light three LED candles',
                'Open exactly 13 browser tabs',
                'Type your true name backwards',
                'Delete your oldest saved file',
                'Whisper to your webcam at 3:33',
                'Create a folder named "void"',
                'Send an email to yourself',
                'Clear your cache three times',
                'Disconnect from WiFi for 66 seconds',
                'Screenshot your desktop',
                'Change your wallpaper to pure black',
                'Mute all sounds except system sounds'
            ];
            
            const bindings = [];
            for (let i = 0; i < 3; i++) {
                bindings.push(actions[Math.floor(random() * actions.length)]);
            }
            
            return { name, title, potency, volatility, resonance, abilities, bindings, seed };
        }
        
        // Draw entity sigil
        function drawEntity(entity) {
            const canvas = document.getElementById('entity-canvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Seeded random for consistent drawing
            let s = entity.seed;
            const random = () => {
                s = (s * 16807) % 2147483647;
                return (s - 1) / 2147483646;
            };
            
            // Draw outer circle
            ctx.strokeStyle = '#330000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 120, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw inner geometric pattern
            ctx.strokeStyle = '#660000';
            ctx.lineWidth = 1;
            
            const points = Math.floor(random() * 5) + 5;
            const radius = 80;
            
            for (let i = 0; i < points; i++) {
                const angle1 = (Math.PI * 2 / points) * i;
                const angle2 = (Math.PI * 2 / points) * ((i + 2) % points);
                
                const x1 = centerX + Math.cos(angle1) * radius;
                const y1 = centerY + Math.sin(angle1) * radius;
                const x2 = centerX + Math.cos(angle2) * radius;
                const y2 = centerY + Math.sin(angle2) * radius;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Draw entity core
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 40);
            gradient.addColorStop(0, `rgba(204, 0, 0, ${random() * 0.5 + 0.3})`);
            gradient.addColorStop(1, 'rgba(204, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw glyphs
            ctx.strokeStyle = '#440000';
            ctx.lineWidth = 1;
            const glyphCount = Math.floor(random() * 8) + 8;
            
            for (let i = 0; i < glyphCount; i++) {
                const angle = (Math.PI * 2 / glyphCount) * i;
                const x = centerX + Math.cos(angle) * 100;
                const y = centerY + Math.sin(angle) * 100;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + Math.PI / 2);
                
                // Draw random glyph
                ctx.beginPath();
                if (random() > 0.5) {
                    ctx.moveTo(-5, -5);
                    ctx.lineTo(5, 5);
                    ctx.moveTo(-5, 5);
                    ctx.lineTo(5, -5);
                } else {
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                }
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Display entity
        async function revealEntity(seedOverride = null) {
            const entity = await generateEntity(seedOverride);
            currentEntity = entity;
            
            // Store in session only if it's the user's own entity
            if (!seedOverride) {
                sessionStorage.setItem('conjuredEntity', JSON.stringify(entity));
            }
            
            // Populate display
            document.getElementById('entity-name').textContent = entity.name;
            document.getElementById('entity-title').textContent = entity.title;
            document.getElementById('stat-potency').textContent = entity.potency;
            document.getElementById('stat-volatility').textContent = entity.volatility + '%';
            document.getElementById('stat-resonance').textContent = entity.resonance + 'Hz';
            
            // Abilities
            document.getElementById('abilities-list').innerHTML = '';
            entity.abilities.forEach(ability => {
                const div = document.createElement('div');
                div.className = 'ability';
                div.textContent = '◉ ' + ability;
                document.getElementById('abilities-list').appendChild(div);
            });
            
            // Binding steps
            const bindingSteps = document.getElementById('binding-steps');
            bindingSteps.innerHTML = ''; // Clear previous
            entity.bindings.forEach((step, i) => {
                const div = document.createElement('div');
                div.className = 'binding-step';
                div.textContent = step;
                bindingSteps.appendChild(div);
            });
            
            // Share URL
            const shareUrl = `${window.location.origin}?summon=${entity.seed}`;
            document.getElementById('share-url').textContent = shareUrl;
            
            // Draw sigil
            drawEntity(entity);
            
            // Reveal
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('entity-reveal').style.display = 'block';
            }, 2000);
        }
        
        // Copy to clipboard
        function copyToClipboard() {
            const url = document.getElementById('share-url').textContent;
            navigator.clipboard.writeText(url).then(() => {
                const el = document.getElementById('share-url');
                el.style.background = '#1a1a1a';
                el.style.color = '#fff';
                setTimeout(() => {
                    el.style.background = '#111';
                    el.style.color = '#666';
                }, 200);
            });
        }
        
        // Check for existing entity or summon parameter
        window.onload = () => {
            const urlParams = new URLSearchParams(window.location.search);
            const summonSeed = urlParams.get('summon');
            
            if (summonSeed) {
                // Someone shared their entity - show it with special message
                revealEntity(parseInt(summonSeed));
                
                // Add viewing notice and visual changes
                setTimeout(() => {
                    const warning = document.querySelector('.warning');
                    warning.innerHTML = 'You are viewing another\'s bound entity.<br>Return to <a href="/" style="color: #666;">conjur.in</a> to discover your own.';
                    
                    // Add visual indicator
                    document.getElementById('entity-canvas').classList.add('viewing-other');
                    
                    // Add notice before share section
                    const shareSection = document.querySelector('.share-section');
                    const notice = document.createElement('div');
                    notice.className = 'other-entity-notice';
                    notice.innerHTML = '⚠ This entity is bound to another soul. You cannot command it.';
                    shareSection.parentNode.insertBefore(notice, shareSection);
                }, 2100);
            } else {
                const existing = sessionStorage.getItem('conjuredEntity');
                if (existing) {
                    // Redisplay existing entity
                    const entity = JSON.parse(existing);
                    currentEntity = entity;
                    
                    document.getElementById('entity-name').textContent = entity.name;
                    document.getElementById('entity-title').textContent = entity.title;
                    document.getElementById('stat-potency').textContent = entity.potency;
                    document.getElementById('stat-volatility').textContent = entity.volatility + '%';
                    document.getElementById('stat-resonance').textContent = entity.resonance + 'Hz';
                    
                    document.getElementById('abilities-list').innerHTML = '';
                    entity.abilities.forEach(ability => {
                        const div = document.createElement('div');
                        div.className = 'ability';
                        div.textContent = '◉ ' + ability;
                        document.getElementById('abilities-list').appendChild(div);
                    });
                    
                    const bindingSteps = document.getElementById('binding-steps');
                    bindingSteps.innerHTML = ''; // Clear previous
                    entity.bindings.forEach((step, i) => {
                        const div = document.createElement('div');
                        div.className = 'binding-step';
                        div.textContent = step;
                        bindingSteps.appendChild(div);
                    });
                    
                    const shareUrl = `${window.location.origin}?summon=${entity.seed}`;
                    document.getElementById('share-url').textContent = shareUrl;
                    
                    drawEntity(entity);
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('entity-reveal').style.display = 'block';
                } else {
                    // First time - generate new entity
                    revealEntity();
                }
            }
        };
    </script>
</body>
</html>